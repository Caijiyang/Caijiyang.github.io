<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"caijiyang.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文包含 Go 语言的基本语法内容，内容参考下列网站：微软培训 Go - TrainingGo 语言数据类型 | 菜鸟教程Go语言官方库">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言基础">
<meta property="og:url" content="http://caijiyang.gitee.io/2023/07/12/1%20%E5%90%8E%E7%AB%AF/1.4%20Go/Go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="软件工程学习记录">
<meta property="og:description" content="本文包含 Go 语言的基本语法内容，内容参考下列网站：微软培训 Go - TrainingGo 语言数据类型 | 菜鸟教程Go语言官方库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/755493/1677835818544-fd285aa5-4b58-4de5-9c3f-e8532c4e1dd6.png#averageHue=%23f2f3f3&clientId=u5b0833e5-c04c-4&from=paste&id=u666d9ef9&originHeight=714&originWidth=1654&originalType=url&ratio=1.75&rotation=0&showTitle=false&size=428499&status=done&style=none&taskId=u5483869d-f686-439c-83c8-25a5c11aeca&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/755493/1680744147336-aab51103-22cb-4edd-bd64-83e90af63705.png#averageHue=%23f6f6f6&clientId=u81d23e52-3954-4&from=paste&height=401&id=ucabcc682&originHeight=489&originWidth=405&originalType=url&ratio=2&rotation=0&showTitle=false&size=35331&status=done&style=none&taskId=ub474b580-5c5a-4a1f-9c28-cbc155e4ce5&title=&width=332">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/755493/1680786723248-4532fadc-9734-42f4-96e8-a129d47af4d0.png#averageHue=%23f7f7f6&clientId=u2357188c-3497-4&from=paste&height=469&id=u8d99c09a&originHeight=516&originWidth=774&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=76127&status=done&style=none&taskId=u1ed1b665-6579-4169-b9d0-9926f7f5631&title=&width=703.6363483854565">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/755493/1682301503495-39d793fb-3e17-44ff-a300-98915749a0ac.webp#averageHue=%23fdfbf7&clientId=ua705f9fa-dc00-4&from=paste&id=u28948486&originHeight=854&originWidth=1818&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u33793d15-10e6-4672-8c5a-26aaa472707&title=">
<meta property="article:published_time" content="2023-07-12T03:21:35.000Z">
<meta property="article:modified_time" content="2023-07-12T03:24:22.135Z">
<meta property="article:author" content="Felix&#x2F;蔡济阳">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/755493/1677835818544-fd285aa5-4b58-4de5-9c3f-e8532c4e1dd6.png#averageHue=%23f2f3f3&clientId=u5b0833e5-c04c-4&from=paste&id=u666d9ef9&originHeight=714&originWidth=1654&originalType=url&ratio=1.75&rotation=0&showTitle=false&size=428499&status=done&style=none&taskId=u5483869d-f686-439c-83c8-25a5c11aeca&title=">


<link rel="canonical" href="http://caijiyang.gitee.io/2023/07/12/1%20%E5%90%8E%E7%AB%AF/1.4%20Go/Go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://caijiyang.gitee.io/2023/07/12/1%20%E5%90%8E%E7%AB%AF/1.4%20Go/Go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","path":"2023/07/12/1 后端/1.4 Go/Go-语言基础/","title":"Go 语言基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go 语言基础 | 软件工程学习记录</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?13b96e46c6da189ca2c0427d8c4295e4"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">软件工程学习记录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Felix/蔡济阳 个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86Go%E5%92%8C%E5%85%B6%E5%8E%86%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">认识Go和其历史</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2"><span class="nav-number">1.1.</span> <span class="nav-text">历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.</span> <span class="nav-text">Go 原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">用例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Go"><span class="nav-number">2.</span> <span class="nav-text">安装Go</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-CentOS"><span class="nav-number">2.1.</span> <span class="nav-text">linux-CentOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows"><span class="nav-number">2.2.</span> <span class="nav-text">Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="nav-number">2.2.1.</span> <span class="nav-text">配置工作区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.2.</span> <span class="nav-text">工作区说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go-env-%E8%AF%B4%E6%98%8E"><span class="nav-number">3.</span> <span class="nav-text">Go env 说明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-amp-%E5%8F%98%E9%87%8F-amp-%E5%B8%B8%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">声明&amp;变量&amp;常量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-amp-%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.</span> <span class="nav-text">声明&amp;变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.</span> <span class="nav-text">初始化操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F"><span class="nav-number">4.3.</span> <span class="nav-text">声明常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iota"><span class="nav-number">4.4.</span> <span class="nav-text">iota</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">4.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97"><span class="nav-number">5.1.1.</span> <span class="nav-text">数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rune"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">rune</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">浮点数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="nav-number">5.1.2.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.1.3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">转义字符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">5.1.4.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.1.5.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">聚合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">声明数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">初始化数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%9C%81%E7%95%A5%E5%8F%B7"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">数组中的省略号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.2.</span> <span class="nav-text">结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">声明和初始化结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%B5%8C%E5%85%A5"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">结构嵌入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-JSON-%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">用 JSON 编码和解码结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">5.3.1.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main-%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">main 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">自定义函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">返回多个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%88%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">更改函数参数值（指针）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">5.3.3.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%87%E7%89%87"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">声明和初始化切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%89%87%E9%A1%B9"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">切片项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E9%A1%B9"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">追加项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%A1%B9"><span class="nav-number">5.3.3.4.</span> <span class="nav-text">删除项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87%E7%9A%84%E5%89%AF%E6%9C%AC-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.3.3.5.</span> <span class="nav-text">创建切片的副本[深浅拷贝]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84-Map"><span class="nav-number">5.3.4.</span> <span class="nav-text">映射 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%98%A0%E5%B0%84"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">声明和初始化映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E9%A1%B9"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">添加项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E9%A1%B9"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">访问项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%A1%B9-1"><span class="nav-number">5.3.4.4.</span> <span class="nav-text">删除项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="nav-number">5.3.4.5.</span> <span class="nav-text">映射中的循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-map"><span class="nav-number">5.3.4.6.</span> <span class="nav-text">sync.map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">5.3.5.</span> <span class="nav-text">通道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text">接口类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">6.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#main%E5%8C%85"><span class="nav-number">6.1.</span> <span class="nav-text">main包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8C%85"><span class="nav-number">6.2.</span> <span class="nav-text">创建包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"><span class="nav-number">6.3.</span> <span class="nav-text">创建模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8C%85%EF%BC%88%E6%A8%A1%E5%9D%97%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">引用本地包（模块）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E5%8C%85"><span class="nav-number">6.5.</span> <span class="nav-text">发布包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89%E5%8C%85"><span class="nav-number">6.6.</span> <span class="nav-text">引用外部（第三方）包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">7.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-x2F-else-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">if&#x2F;else 条件表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">7.2.</span> <span class="nav-text">switch 控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">7.2.1.</span> <span class="nav-text">多表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.2.</span> <span class="nav-text">调用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.2.3.</span> <span class="nav-text">省略条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E9%80%BB%E8%BE%91%E8%BF%9B%E5%85%A5%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA-case"><span class="nav-number">7.2.4.</span> <span class="nav-text">使逻辑进入到下一个 case</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.3.</span> <span class="nav-text">for 循环表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.3.1.</span> <span class="nav-text">空的预处理语句和后处理语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%92%8C-break-%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.3.2.</span> <span class="nav-text">无限循环和 break 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Continue-%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.3.3.</span> <span class="nav-text">Continue 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer-x2F-panic-x2F-recover%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">defer&#x2F;panic&#x2F;recover函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.1.</span> <span class="nav-text">defer 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panic-%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.2.</span> <span class="nav-text">panic 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recover-%E5%87%BD%E6%95%B0%E3%80%90%E7%B1%BB%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%91"><span class="nav-number">7.4.3.</span> <span class="nav-text">recover 函数【类异常处理】</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">8.</span> <span class="nav-text">错误处理和日志记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">8.1.1.</span> <span class="nav-text">错误处理策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">8.1.2.</span> <span class="nav-text">创建可重用的错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95"><span class="nav-number">8.1.3.</span> <span class="nav-text">用于错误处理的推荐做法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">8.2.</span> <span class="nav-text">日志记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#log-%E5%8C%85"><span class="nav-number">8.2.1.</span> <span class="nav-text">log 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.2.</span> <span class="nav-text">记录到文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%A1%86%E6%9E%B6"><span class="nav-number">8.2.3.</span> <span class="nav-text">记录框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">8.3.</span> <span class="nav-text">重点总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">方法和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.1.</span> <span class="nav-text">声明方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">9.1.2.</span> <span class="nav-text">方法中的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.3.</span> <span class="nav-text">声明其他类型的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.4.</span> <span class="nav-text">嵌入方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.5.</span> <span class="nav-text">重载方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.6.</span> <span class="nav-text">封装方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.7.</span> <span class="nav-text">匿名方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.1.</span> <span class="nav-text">声明接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.2.</span> <span class="nav-text">实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.3.</span> <span class="nav-text">实现字符串接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.2.4.</span> <span class="nav-text">扩展所有实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%99%A8API"><span class="nav-number">9.2.5.</span> <span class="nav-text">编写自定义服务器API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">10.</span> <span class="nav-text">并发 *</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-goruntine%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">了解 goruntine（轻量线程） *</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.1.1.</span> <span class="nav-text">Go 实现并发的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine"><span class="nav-number">10.1.2.</span> <span class="nav-text">Goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime%E5%8C%85"><span class="nav-number">10.1.3.</span> <span class="nav-text">runtime包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.1.4.</span> <span class="nav-text">编写并发程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86-channel-%E7%94%A8%E4%BD%9C%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">10.2.</span> <span class="nav-text">将 channel 用作通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E8%AF%AD%E6%B3%95"><span class="nav-number">10.2.1.</span> <span class="nav-text">Channel 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2-channel"><span class="nav-number">10.2.2.</span> <span class="nav-text">无缓冲 channel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E6%9C%89%E7%BC%93%E5%86%B2-channel"><span class="nav-number">10.3.</span> <span class="nav-text">了解有缓冲 channel</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Felix/蔡济阳"
      src="/myimages/Pixels_trophy.png">
  <p class="site-author-name" itemprop="name">Felix/蔡济阳</p>
  <div class="site-description" itemprop="description">记录学习的点滴</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Caijiyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Caijiyang" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:caijiyan6@163.com" title="E-Mail → mailto:caijiyan6@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN,en" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://github.com/Caijiyang" title="https:&#x2F;&#x2F;github.com&#x2F;Caijiyang" rel="noopener" target="_blank">GitHub</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://gitee.com/caijiyang" title="https:&#x2F;&#x2F;gitee.com&#x2F;caijiyang" rel="noopener" target="_blank">Gitee</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://blog.csdn.net/qq_43266597?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_43266597?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">CSDN</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://caijiyang.gitee.io/2023/07/12/1%20%E5%90%8E%E7%AB%AF/1.4%20Go/Go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/myimages/Pixels_trophy.png">
      <meta itemprop="name" content="Felix/蔡济阳">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="软件工程学习记录">
      <meta itemprop="description" content="记录学习的点滴">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go 语言基础 | 软件工程学习记录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 语言基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-12 11:21:35 / 修改时间：11:24:22" itemprop="dateCreated datePublished" datetime="2023-07-12T11:21:35+08:00">2023-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">1 后端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/1-%E5%90%8E%E7%AB%AF/1-4-Go/" itemprop="url" rel="index"><span itemprop="name">1.4 Go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文包含 Go 语言的基本语法内容，内容参考下列网站：<br><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/training/paths/go-first-steps/">微软培训 Go - Training</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-data-types.html">Go 语言数据类型 | 菜鸟教程</a><br><a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki">Go语言官方库</a></p>
<span id="more"></span>

<h1 id="认识Go和其历史"><a href="#认识Go和其历史" class="headerlink" title="认识Go和其历史"></a>认识Go和其历史</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Go 是 Google 开发的一种编程语言。 它于 2009 年由 Robert Griesemer、Rob Pike 和 Ken Thompson 作为开源项目发布。 从那时起，Go 语言就被用于开发其他众所周知的技术，如 Docker、Kubernetes 和 Terraform。 尽管 Go 语言在服务器端和云软件中广泛使用，但它是一种常规用途语言，具有丰富的不同用例。<br>Go 语言表现力强，且简单明了。 它在设计时考虑了惯用语言，这使程序员能够高效地编写高效且可靠的代码。 以 Go 语言编写的程序可以在 Unix 系统上运行，例如 Linux 和 macOS，也可以在 Windows 系统上运行。 Go 语言之所以值得注意，部分原因在于它独特的并发机制，使得编写可同时利用多个内核的程序非常容易。 它主要是一种强化静态类型的语言，这意味着变量类型在编译时是已知的。 不过，它确实具有一些动态类型化功能。<br>根据 TIOBE 索引，Go 是 2009 和 2016 年的年度编程语言。 尽管 Go 在 2016 年达到了顶点，但它仍保持着很好的口碑。 根据年度 Stack Overflow 开发人员调查，Go 仍然是最受欢迎的语言之一。<br>Go 语言与 C 语言有很多相似之处，它继承了 C 语言语法的许多方面，如控制流语句、基本数据类型、指针和其他元素等。 不过，该语言的语法和语义均超出 C 语言。 它还与 Java、C#、Python 等有相似之处。 一般情况下，Go 语言往往从其他编程语言中借用并调整功能，同时去掉了大部分复杂性。 例如，你可以在 Go 语言中使用一些面向对象的 (OO) 编程功能和设计模式，但并不完全实现整个 OO 范例。 你将在此学习路径的后面部分了解其中的原因。</p>
<h2 id="Go-原则"><a href="#Go-原则" class="headerlink" title="Go 原则"></a>Go 原则</h2><p>下面是 Go 编程语言的基本原理优势：</p>
<ol>
<li>Go 许可证是完全开放源代码的。</li>
<li>Go 程序编译为单独的二进制文件，这样更易于共享和分发。</li>
<li>Go 支持交叉编辑到各种平台和操作系统。</li>
<li>Go 语言致力于使语言变得简单，并用更少的代码行执行更多操作。</li>
<li>并发是头等概念，使任何函数可以作为轻量级线程运行，而程序员只需少量工作。</li>
<li>Go 语言提供自动内存管理，包括垃圾回收。</li>
<li>编译和执行速度很快。</li>
<li>Go 语言需要使用所有代码，否则会引发错误。</li>
<li>有一种官方格式设置可帮助保持项目之间的一致性。</li>
<li>Go 语言具有大量全面标准库，并且可以在不使用第三方依赖项的情况下生成多个应用程序。</li>
<li>Go 保证语言与以前版本的后向兼容性。</li>
</ol>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><ul>
<li>系统级应用程序</li>
<li>Web 应用程序</li>
<li>云原生应用程序</li>
<li>实用工具和命令行工具</li>
<li>分布式系统</li>
<li>数据库实现</li>
</ul>
<h1 id="安装Go"><a href="#安装Go" class="headerlink" title="安装Go"></a>安装Go</h1><h2 id="linux-CentOS"><a href="#linux-CentOS" class="headerlink" title="linux-CentOS"></a>linux-CentOS</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/755493/1677835818544-fd285aa5-4b58-4de5-9c3f-e8532c4e1dd6.png#averageHue=%23f2f3f3&clientId=u5b0833e5-c04c-4&from=paste&id=u666d9ef9&originHeight=714&originWidth=1654&originalType=url&ratio=1.75&rotation=0&showTitle=false&size=428499&status=done&style=none&taskId=u5483869d-f686-439c-83c8-25a5c11aeca&title=" alt="image.png"><br>第一步，安装 wget</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure>

<p>第二步，下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://dl.google.com/go/go1.20.1.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置环境变量<br>创建GOPATH文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir gopath </span><br></pre></td></tr></table></figure>

<p>打开配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>更改配置信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc/profile最后一行添加，GOPATH路径更换成上面创建的路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i 切换更改模式</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line">export GO111MODULE=&quot;on&quot; # 开启 Go moudles 特性</span><br><span class="line">export GOPROXY=https://goproxy.cn,direct # 安装 Go 模块时，国内代理服务器设置</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">esc 推出更改模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:wq 保存更改后退出</span></span><br></pre></td></tr></table></figure>

<p>使环境变量立刻生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>查看版本号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>

<p>查看环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows上安装GO只需要在官网上下载 GO 语言的安装包即可。<br>下载地址：<a target="_blank" rel="noopener" href="https://go.dev/dl/">https://go.dev/dl/</a><br>安装完毕之后，在命令行中输入一下命令即可完成通话：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>

<h3 id="配置工作区"><a href="#配置工作区" class="headerlink" title="配置工作区"></a>配置工作区</h3><p>1.为所有 Go 项目创建一个顶级文件夹。 例如，<code>C:\Projects\Go</code>。<br>2.打开 PowerShell 提示符，然后运行以下 cmdlet 来设置 <code>$GOPATH</code>环境变量。<br>将 <code>&lt;project-folder&gt;</code> 替换为上一步中创建的顶级项目文件夹。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Environment</span>]::SetEnvironmentVariable(<span class="string">&quot;GOPATH&quot;</span>, <span class="string">&quot;&lt;project-folder&gt;&quot;</span>, <span class="string">&quot;User&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>3.确认 <code>$GOPATH</code> 变量显示正确的工作区位置。 在新的提示符窗口中，运行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env GOPATH</span><br></pre></td></tr></table></figure>

<p>输出显示当前工作区位置为顶级项目文件夹：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Projects\Go</span><br></pre></td></tr></table></figure>

<h3 id="工作区说明"><a href="#工作区说明" class="headerlink" title="工作区说明"></a>工作区说明</h3><p>每个 Go 工作区都包含三个基本文件夹：</p>
<ul>
<li>bin：包含应用程序中的可执行文件。</li>
<li>src：包括位于工作站中的所有应用程序源代码。</li>
<li>pkg：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。</li>
</ul>
<p>例如，工作站文件夹结构树可能与下面的示例类似：</p>
<blockquote>
<p>bin&#x2F;<br> hello<br> coolapp<br>pkg&#x2F;<br> github.com&#x2F;gorilla&#x2F;<br>     mux.a<br>src&#x2F;<br> github.com&#x2F;golang&#x2F;example&#x2F;<br>     .git&#x2F;<br> hello&#x2F;<br>     hello.go</p>
</blockquote>
<p>为工作区创建三个子文件夹：<code>bin</code>、<code>pkg</code>、<code>src</code></p>
<h1 id="Go-env-说明"><a href="#Go-env-说明" class="headerlink" title="Go env 说明"></a>Go env 说明</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">set GO111MODULE=</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">set GOBIN=</span><br><span class="line">set GOCACHE=C:\Users\<span class="number">16496</span>\AppData\Local\<span class="keyword">go</span>-build</span><br><span class="line">set GOENV=C:\Users\<span class="number">16496</span>\AppData\Roaming\<span class="keyword">go</span>\env</span><br><span class="line">set GOEXE=.exe</span><br><span class="line">set GOEXPERIMENT=</span><br><span class="line">set GOFLAGS=</span><br><span class="line">set GOHOSTARCH=amd64</span><br><span class="line">set GOHOSTOS=windows</span><br><span class="line">set GOINSECURE=</span><br><span class="line">set GOMODCACHE=D:\Code\GoProjects\pkg\mod</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOOS=windows</span><br><span class="line">set GOPATH=D:\Code\GoProjects</span><br><span class="line">set GOPRIVATE=</span><br><span class="line">set GOPROXY=https:<span class="comment">//mirrors.aliyun.com/goproxy/</span></span><br><span class="line">set GOROOT=C:\Program Files\Go</span><br><span class="line">set GOSUMDB=sum.golang.org</span><br><span class="line">set GOTMPDIR=</span><br><span class="line">set GOTOOLDIR=C:\Program Files\Go\pkg\tool\windows_amd64</span><br><span class="line">set GOVCS=</span><br><span class="line">set GOVERSION=go1<span class="number">.20</span><span class="number">.1</span></span><br><span class="line">set GCCGO=gccgo</span><br><span class="line">set GOAMD64=v1</span><br><span class="line">set AR=ar</span><br><span class="line">set CC=gcc</span><br><span class="line">set CXX=g++</span><br><span class="line">set CGO_ENABLED=<span class="number">0</span></span><br><span class="line">set GOMOD=NUL</span><br><span class="line">set GOWORK=</span><br><span class="line">set CGO_CFLAGS=-O2 -g</span><br><span class="line">set CGO_CPPFLAGS=</span><br><span class="line">set CGO_CXXFLAGS=-O2 -g</span><br><span class="line">set CGO_FFLAGS=-O2 -g</span><br><span class="line">set CGO_LDFLAGS=-O2 -g</span><br><span class="line">set PKG_CONFIG=pkg-config</span><br><span class="line">set GOGCCFLAGS=-m64 -fno-caret-diagnostics -Qunused-arguments -Wl,--no-gc-sections -fmessage-length=<span class="number">0</span> -fdebug-prefix-<span class="keyword">map</span>=C:\Users\<span class="number">16496</span>\AppData\Local\Temp\<span class="keyword">go</span>-build190679691=/tmp/<span class="keyword">go</span>-build -gno-record-gcc-switches</span><br></pre></td></tr></table></figure>

<h1 id="声明-amp-变量-amp-常量"><a href="#声明-amp-变量-amp-常量" class="headerlink" title="声明&amp;变量&amp;常量"></a>声明&amp;变量&amp;常量</h1><h2 id="声明-amp-变量"><a href="#声明-amp-变量" class="headerlink" title="声明&amp;变量"></a>声明&amp;变量</h2><p>若要声明变量，需要使用 <code>var</code> 关键字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstname <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>声明 string 类型中的一个名为 <code>firstName</code> 的变量。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstname. lastname <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>通过在变量名称后面添加逗号<code> ,</code>，就表示你将要声明其他变量。 在这种情况下，前一个语句就声明了 string 类型中的两个变量：<code>firstName</code>和<code>lastName</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fristname, lastname <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fristname, lastname <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    firstname <span class="type">string</span> = <span class="string">&quot;Felix&quot;</span></span><br><span class="line">    lastname <span class="type">string</span> = <span class="string">&quot;cai&quot;</span></span><br><span class="line">    age <span class="type">int</span> = <span class="number">23</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fristname = <span class="string">&quot;Felix&quot;</span></span><br><span class="line">    lastname = <span class="string">&quot;cai&quot;</span></span><br><span class="line">    age = <span class="number">23</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当你想要初始化一个变量的时候，是不需要指定其类型的，Go 会自动判断这个变量的类型。Go 将推断出变量 <code>firstName </code>和 <code>lastName</code> 的类型为 <code>string</code>，并且变量 <code>age</code> 属于 <code>int</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    firstname, lastname, age = <span class="string">&quot;Felix&quot;</span>, <span class="string">&quot;Cai&quot;</span>, <span class="number">23</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当然，下面是在 Go 中最常用的赋值方式，冒等号 <code>:=</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    firstname, lastname := <span class="string">&quot;Felix&quot;</span>, <span class="string">&quot;Cai&quot;</span></span><br><span class="line">    age := <span class="number">23</span></span><br><span class="line">    fmt.Println(fristname, lastname, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意 <code>import &quot;fmt&quot;</code> 语句。 我们使用 <code>import</code> 关键字将包的内容引入范围中。 我们要导入“<code>fmt</code>”包，因此可以在代码中使用 <code>Println</code> 方法。 我们将在后面的单元中详细了解此关键字。</p>
</blockquote>
<p>请注意，在定义变量名称后，需要在此处加入一个冒号等于号 <code>:=</code> 和相应的值。 使用冒号等于号时，要声明的变量必须是新变量。 如果使用冒号等于号并已经声明该变量，将不会对程序进行编译。 </p>
<h2 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h2><p>有时，你需要在代码中加入静态值，这称为常量。 Go 支持使用常量。 用于声明常量的关键字是 <code>const</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fristInt = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>与变量一样，Go 可以通过分配给常量的值推断出类型。 在 Go 中，常量名称通常以混合大小写字母或全部大写字母书写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Aconst = <span class="number">0</span></span><br><span class="line">    BCONST = <span class="number">1</span></span><br><span class="line">    Cconst = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code> 是一个关键字！简单理解为常量计数器，特殊常量，可以认为是一个可以被编译器修改的常量。<br><code>iota</code> 在 <code>const</code> 关键字出现时将被重置为 0 (<code>const</code> 内部的第一行之前)，<code>const</code> 中每新增一行常量声明将使 <code>iota</code> 计数一次(<code>iota</code> 可理解为 <code>const</code> 语句块中的行索引)。<br>这里有几个有趣的例子：<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/Iota">官网上的两个案例</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span> + <span class="number">1</span> <span class="comment">// iota: 0 ~ Sunday : 1</span></span><br><span class="line">    _ 						  <span class="comment">// iota: 1 ~ iota increased</span></span><br><span class="line">    <span class="comment">// comments               // iota: 1 ~ skip comment</span></span><br><span class="line">                              <span class="comment">// iota: 1 ~ skip empty line</span></span><br><span class="line">    Monday                    <span class="comment">// iota: 2 ~ Monday : 3</span></span><br><span class="line">    Tuesday                   <span class="comment">// iota: 3 ~ Tuesday : 4</span></span><br><span class="line">    Wednesday                 <span class="comment">// iota: 4 ~ Wednesday : 5</span></span><br><span class="line">    Thursday                  <span class="comment">// iota: 5 ~ Thursday : 6</span></span><br><span class="line">    Friday                    <span class="comment">// iota: 6 ~ Friday : 7</span></span><br><span class="line">    Saturday                  <span class="comment">// iota: 7 ~ Saturday : 8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-constants.html">菜鸟教程</a>上的一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下为输出：</span></span><br><span class="line"><span class="comment">i= 1</span></span><br><span class="line"><span class="comment">j= 6</span></span><br><span class="line"><span class="comment">k= 12</span></span><br><span class="line"><span class="comment">l= 24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>:::info<br>注：&lt;&lt;n&#x3D;&#x3D;*(2^n)<br>:::</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>常量的声明<strong>不能</strong>使用 <code>:=</code></li>
<li>变量声明了必须<strong>要使用</strong>，否则会报错</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Go 是一种强类型语言。 你声明的每个变量都绑定到特定的数据类型，并且只接受与此类型匹配的值。<br>Go 有四类数据类型：</p>
<ul>
<li><strong>基本类型</strong>：数字、字符串和布尔值</li>
<li><strong>聚合类型</strong>：数组和结构</li>
<li><strong>引用类型</strong>：指针、切片、映射、函数和通道</li>
<li><strong>接口类型</strong>：接口</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>一般来说，定义整数类型的关键字是 <code>int</code>。 但 Go 还提供了 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 类型，其大小分别为 8、16、32 或 64 位的整数。 使用 32 位操作系统时，如果只是使用 int，则大小通常为 32 位。 在 64 位系统上，int 大小通常为 64 位。 但是，此行为可能因计算机而不同。<br>只有在出于某种原因需要将值表示为无符号数字的情况下，才使用 <code>uint</code> 类型。 此外，Go 还提供 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> integer8 <span class="type">int8</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> integer16 <span class="type">int16</span> = <span class="number">32767</span></span><br><span class="line"><span class="keyword">var</span> integer32 <span class="type">int32</span> = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">var</span> integer64 <span class="type">int64</span> = <span class="number">9223372036854775807</span></span><br><span class="line">fmt.Println(integer8, integer16, integer32, integer64)</span><br></pre></td></tr></table></figure>

<p>大多数情况都是使用 <code>int</code>，但需要了解其他整数类型，因为在 Go 中，<code>int</code> 与 <code>int32</code> 不同，即使整数的自然大小为 32 位也是如此。<br>在 Go 中将值从一种类型转换为另一种类型时，需要显式声明新类型。 </p>
<h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><p>有时可能会收到有关 runes 的信息。 <code>rune</code> 只是 <code>int32</code> 数据类型的别名。 它用于表示 Unicode 字符（或 Unicode 码位）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rune</span> := <span class="string">&#x27;G&#x27;</span></span><br><span class="line">fmt.Println(<span class="type">rune</span>)</span><br><span class="line"><span class="comment">// 输出 71 ，它表示 G 的 Unicode 字符</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>Go 提供两种浮点数大小的数据类型：<code>float32</code> 和 <code>float64</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">float32</span> <span class="type">float32</span> = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">float64</span> <span class="type">float64</span> = <span class="number">9223372036854775807</span></span><br><span class="line">fmt.Println(<span class="type">float32</span>, <span class="type">float64</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用 math 包中提供的 math.MaxFloat32 和 math.MaxFloat64 常量来查找这两种类型的限制</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.MaxFloat32, math.MaxFloat64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="number">2.71828</span></span><br><span class="line"><span class="keyword">const</span> Avogadro = <span class="number">6.02214129e23</span></span><br><span class="line"><span class="keyword">const</span> Planck = <span class="number">6.62606957e-34</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔类型仅可能有两个值：<code>true</code> 和 <code>false</code>。 你可以使用关键字 <code>bool</code> 声明布尔类型。 Go 与其他编程语言不同。 在 Go 中，不能将布尔类型隐式转换为 0 或 1。 你必须显式执行此操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> featureFlag <span class="type">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>关键字 <code>string</code> 用于表示字符串数据类型。 若要初始化字符串变量，你需要在双引号<code>&quot;</code>中定义值。 单引号<code>&#39;</code>用于单个字符（以及 <code>runes</code>，正如我们在上一节所述）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fristname = <span class="string">&quot;Felix&quot;</span></span><br><span class="line">lastname := <span class="string">&quot;Cai&quot;</span></span><br><span class="line">fmt.<span class="built_in">println</span>(fristname, lastname)</span><br></pre></td></tr></table></figure>

<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><ul>
<li><code>\n</code>：新行</li>
<li><code>\r</code>：回车符</li>
<li><code>\t</code>：制表符</li>
<li><code>\&#39;</code>：单引号</li>
<li><code>\&quot;</code>：双引号</li>
<li><code>\\</code>：反斜杠</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName = <span class="string">&quot;Felix\tCai&quot;</span></span><br><span class="line">fmt.Println(fullName)</span><br></pre></td></tr></table></figure>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。在使用之前，无需检查变量是否已初始化。</p>
<ul>
<li><code>int</code>及其子类型（如 <code>int64</code>），默认值为<code>0</code></li>
<li><code>float32</code>和 <code>float64</code> 默认值为 <code>+0.000000e+000</code></li>
<li><code>bool</code>默认值为<code>false</code></li>
<li><code>string</code>默认值为空值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> defaultFloat32 <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> defaultFloat64 <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> defaultBool <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> defaultString <span class="type">string</span></span><br><span class="line">fmt.Println(defaultInt, defaultFloat32, defaultFloat64, defaultBool, defaultString)</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在 Go 中，提供了显式强制转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> integer16 <span class="type">int16</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> integer32 <span class="type">int32</span> = <span class="number">32767</span></span><br><span class="line">fmt.Println(<span class="type">int32</span>(integer16)+integer32)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i, _ := strconv.Atoi(<span class="string">&quot;-42&quot;</span>)</span><br><span class="line">    s := strconv.Itoa(<span class="number">-42</span>)</span><br><span class="line">    fmt.Println(i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Go 中的数组是一种<strong>特定类型</strong>且<strong>长度固定</strong>的数据结构。 它们可具有零个或多个元素，你必须在声明或初始化它们时定义大小。 此外，它们一旦创建，就无法调整大小。 鉴于这些原因，数组在 Go 程序中并不常用，但它们是切片和映射的基础。</p>
<h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>要在 Go 中声明数组，必须定义其元素的数据类型以及该数组可容纳的元素数目。 然后，可采用下标表示法访问数组中的每个元素，其中第一个元素是 0，最后一个元素是数组长度减去 1（长度 - 1）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>])</span><br><span class="line">	fmt.Println(a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 默认情况下，Go 会用默认数据类型初始化每个元素。<code>len</code> 函数是 Go 中的内置函数，用于获取数组、切片或映射中的元素数。</p>
<h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>声明数组时，还可使用非默认值来初始化数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cities := [<span class="number">5</span>]<span class="type">string</span>&#123;<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Madrid&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Cities:&quot;</span>, cities)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cities: [New York Paris Berlin Madrid ]</span><br></pre></td></tr></table></figure>

<p>即使数组应具有 5 个元素，也无需为所有元素分配值。 如上所示，最新位置包含一个空的字符串，因为它是字符串数据类型的默认值。</p>
<h4 id="数组中的省略号"><a href="#数组中的省略号" class="headerlink" title="数组中的省略号"></a>数组中的省略号</h4><p>如果你不知道你将需要多少个位置，但知道你将具有多少数据，那么还有一种声明和初始化数组的方法是使用省略号 <code>...</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cities := [...]<span class="type">string</span>&#123;<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;Paris&quot;</span>, <span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Madrid&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cities:&quot;</span>, cities)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cities: [New York Paris Berlin Madrid]</span><br></pre></td></tr></table></figure>

<p>末尾没有空字符串。 数组长度由你初始化它时输入的字符串决定。 如果你不再需要，则不保留你不知道的内存。<br>另一种有趣的数组初始化方法是使用省略号并仅为最新的位置指定值。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;First Position:&quot;</span>, numbers[<span class="number">0</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;Last Position:&quot;</span>, numbers[<span class="number">99</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(numbers))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First Position: <span class="number">0</span></span><br><span class="line">Last Position: <span class="number">-1</span></span><br><span class="line">Length: <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>请注意数组的长度是 100，因为你为第 99 个位置指定了一个值。 第一个位置打印出默认值（零）。</p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>Go 支持多维数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> twoD [<span class="number">3</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            twoD[i][j] = (i + <span class="number">1</span>) * (j + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Row&quot;</span>, i, twoD[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nAll at once:&quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Row <span class="number">0</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">Row <span class="number">1</span> [<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line">Row <span class="number">2</span> [<span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">12</span> <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">All at once: [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] [<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span>] [<span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">12</span> <span class="number">15</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>有时，你需要在一个结构中表示字段的集合。 例如，要编写工资核算程序时，需要使用员工数据结构。 在 Go 中，可使用结构将可能构成记录的不同字段组合在一起。<br>Go 中的结构也是一种数据结构，它可包含零个或多个任意类型的字段，并将它们表示为单个实体。</p>
<h4 id="声明和初始化结构"><a href="#声明和初始化结构" class="headerlink" title="声明和初始化结构"></a>声明和初始化结构</h4><p>若要声明结构，需要使用 <code>struct</code> 关键字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以像操作其他类型一样使用新类型声明一个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john Employee</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee := Employee&#123;<span class="number">1001</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="string">&quot;Doe&#x27;s Street&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，必须为结构中的每个字段指定一个值。 但这有时也可能会导致出现问题。 或者，可更具体地了解要在结构中初始化的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee := Employee&#123;LastName: <span class="string">&quot;Doe&quot;</span>, FirstName: <span class="string">&quot;John&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>请注意从上述声明中看，为每个字段分配值的顺序不重要。 此外，如果未指定任何其他字段的值，也并不重要。 Go 将根据字段数据类型分配默认值。<br>若要访问结构的各个字段，可使用点表示法 (.) 做到这一点，如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employee.ID = <span class="number">1001</span></span><br><span class="line">fmt.Println(employee.FirstName)</span><br></pre></td></tr></table></figure>

<p>最后，可使用 <code>&amp;</code> 运算符生成指向结构的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    employee := Employee&#123;LastName: <span class="string">&quot;Doe&quot;</span>, FirstName: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">    fmt.Println(employee)</span><br><span class="line">    employeeCopy := &amp;employee</span><br><span class="line">    employeeCopy.FirstName = <span class="string">&quot;David&quot;</span></span><br><span class="line">    fmt.Println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span> John Doe &#125;</span><br><span class="line">&#123;<span class="number">0</span> David Doe &#125;</span><br></pre></td></tr></table></figure>

<p>请注意在使用指针时结构是如何变为可变结构的</p>
<h4 id="结构嵌入"><a href="#结构嵌入" class="headerlink" title="结构嵌入"></a>结构嵌入</h4><p>通过 Go 中的结构，可将某结构嵌入到另一结构中。 有时，你需要减少重复并重用一种常见的结构。 例如，假设你想要重构之前的代码，使其具有两种数据类型，一种针对员工，一种针对合同工。 你可具有一个包含公共字段的 <code>Person</code> 结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，你可声明嵌入 <code>Person</code> 类型的其他类型，例如 <code>Employee</code> 和 <code>Contractor</code>。 若要嵌入另一个结构，请创建一个新字段，如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Information Person</span><br><span class="line">    ManagerID   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要引用 <code>Person</code> 结构中的字段，你需要包含员工变量中的 <code>Information</code> 字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee Employee</span><br><span class="line">employee.Information.FirstName = <span class="string">&quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你要像这样重构代码，则会破坏代码。 或者，你可只包含一个与你要嵌入的结构同名的新字段，如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    ManagerID <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    ManagerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contractor <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    CompanyID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    employee := Employee&#123;</span><br><span class="line">        Person: Person&#123;</span><br><span class="line">            FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    employee.LastName = <span class="string">&quot;Doe&quot;</span></span><br><span class="line">    fmt.Println(employee.FirstName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意如何在无需指定 <code>Person</code> 字段的情况下访问 <code>Employee</code> 结构中的 <code>FirstName</code> 字段，因为它会自动嵌入其所有字段。 但在你<strong>初始化</strong>结构时，必须明确要给哪个字段分配值。</p>
<h4 id="用-JSON-编码和解码结构"><a href="#用-JSON-编码和解码结构" class="headerlink" title="用 JSON 编码和解码结构"></a>用 JSON 编码和解码结构</h4><p>可使用结构来对 JSON 中的数据进行编码和解码。 Go 对 JSON 格式提供很好的支持，该格式已包含在标准库包中。<br>你还可执行一些操作，例如重命名结构中字段的名称。 例如，假设你不希望 JSON 输出显示 <code>FirstName</code> 而只显示 <code>name</code>，或者忽略空字段， 可使用如下例所示的字段标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span>    </span><br><span class="line">    FirstName <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span> <span class="string">`json:&quot;address,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要将结构编码为 JSON，请使用 <code>json.Marshal</code> 函数。 若要将 JSON 字符串解码为数据结构，请使用 <code>json.Unmarshal</code> 函数。 下例将所有内容组合在一起，将员工数组编码为 JSON，并将输出解码为新的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span> <span class="string">`json:&quot;address,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    ManagerID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contractor <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    CompanyID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    employees := []Employee&#123;</span><br><span class="line">        Employee&#123;</span><br><span class="line">            Person: Person&#123;</span><br><span class="line">                LastName: <span class="string">&quot;Doe&quot;</span>, FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Employee&#123;</span><br><span class="line">            Person: Person&#123;</span><br><span class="line">                LastName: <span class="string">&quot;Campbell&quot;</span>, FirstName: <span class="string">&quot;David&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data, _ := json.Marshal(employees)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decoded []Employee</span><br><span class="line">    json.Unmarshal(data, &amp;decoded)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v&quot;</span>, decoded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;John&quot;</span><span class="punctuation">,</span><span class="attr">&quot;LastName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Doe&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ManagerID&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;David&quot;</span><span class="punctuation">,</span><span class="attr">&quot;LastName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Campbell&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ManagerID&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">0</span> John Doe <span class="punctuation">&#125;</span> <span class="number">0</span><span class="punctuation">&#125;</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="number">0</span> David Campbell <span class="punctuation">&#125;</span> <span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>程序中只能有一个 <code>main()</code> 函数。 如果创建的是 Go 包，则无需编写 <code>main()</code> 函数。<br>在深入了解如何创建自定义函数的基本知识之前，让我们看看 <code>main()</code> 函数的一个重要特性。 你可能留意到，<code>main()</code> 函数没有任何参数，并且不返回任何内容。 但这并不意味着其不能从用户读取值，如命令行参数。 如要访问 Go 中的命令行参数，可以使用用于保存传递到程序的所有参数的 <code>os</code> 包 和 <code>os.Args</code> 变量来执行操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    number1, _ := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line">    number2, _ := strconv.Atoi(os.Args[<span class="number">2</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sum:&quot;</span>, number1+number2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os.Args</code> 变量包含传递给程序的每个命令行参数。 由于这些值的类型为 <code>string</code>，因此需要将它们转换为 <code>int</code> 以进行求和。<br>若要运行程序，请使用以下命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>下面是用于创建函数的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameters)</span></span> (results) &#123;</span><br><span class="line">    body-content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>func</code> 关键字来定义函数，然后为其指定名称。 在命名后，指定函数的参数列表。 你可以指定零个或多个参数。 你还可以定义函数的返回类型，该函数也可以是零个或多个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := sum(os.Args[<span class="number">1</span>], os.Args[<span class="number">2</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sum:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(number1 <span class="type">string</span>, number2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	int1, _ := strconv.Atoi(number1)</span><br><span class="line">	int2, _ := strconv.Atoi(number2)</span><br><span class="line">	<span class="keyword">return</span> int1 + int2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := <span class="string">&quot;10&quot;</span></span><br><span class="line">	<span class="keyword">if</span> s, err := strconv.Atoi(v); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%T, %v&quot;</span>, s, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 中，你还可以为函数的返回值设置名称，将其当作一个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(number1 <span class="type">string</span>, number2 <span class="type">string</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    int1, _ := strconv.Atoi(number1)</span><br><span class="line">    int2, _ := strconv.Atoi(number2)</span><br><span class="line">    result = int1 + int2</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，现在需要将函数的结果值括在括号中。 你还可以在函数中使用该变量，并且只需在末尾添加 <code>return</code> 行。 Go 将返回这些返回变量的当前值。 在函数末尾编写 <code>return</code> 关键字非常简单方便，尤其是在有多个返回值时。 我们不建议使用此方法。 可能不确定函数将返回什么。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>在 Go 中，函数可以返回多个值。 你可以采用类似于定义函数参数的方式来定义这些值。 换句话说，你可以指定一个类型和名称，但该名称是可选的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(number1 <span class="type">string</span>, number2 <span class="type">string</span>)</span></span> (sum <span class="type">int</span>, mul <span class="type">int</span>) &#123;</span><br><span class="line">	int1, _ := strconv.Atoi(number1)</span><br><span class="line">	int2, _ := strconv.Atoi(number2)</span><br><span class="line">	sum = int1 + int2</span><br><span class="line">	mul = int1 * int2</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改函数参数值（指针）"><a href="#更改函数参数值（指针）" class="headerlink" title="更改函数参数值（指针）"></a>更改函数参数值（指针）</h4><p>Go 是“按值传递”编程语言。和 Java 一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    firstName = <span class="string">&quot;John&quot;</span></span><br><span class="line">    updateName(&amp;fristName)</span><br><span class="line">    fmt.Println(fristName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateName</span><span class="params">(name *<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    *name = <span class="string">&quot;David&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 是取地址符号，用于取得一个变量的地址<br>在上述代码中，<code>*string</code>表明需要接收指针，含义：指向字符串的指针，随后使用<code>*name</code>将变量<code>name</code>的值暂停，随后传入地址，此时，指针<code>name</code>指向变量<code>firsName</code>的地址，如果<code>name</code>改变，<code>fristname</code>也将改变。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>数组是切片和映射的基础。与数组一样，切片也是 Go 中的一种数据类型，它表示一系列类型相同的元素。 不过，与数组更重要的区别是切片的大小是动态的，不是固定的。<br>切片是数组或另一个切片之上的数据结构。 我们将源数组或切片称为基础数组。 通过切片，可访问整个基础数组，也可仅访问部分元素。<br>切片只有 3 个组件：</p>
<ul>
<li><strong>指向基础数组中第一个可访问元素的指针</strong>。 此元素不一定是数组的第一个元素 array[0]。</li>
<li><strong>切片的长度</strong>。 切片中的元素数目。</li>
<li><strong>切片的容量</strong>。 切片开头与基础数组结束之间的元素数目。</li>
</ul>
<p>下图显示了什么是切片：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/755493/1680744147336-aab51103-22cb-4edd-bd64-83e90af63705.png#averageHue=%23f6f6f6&clientId=u81d23e52-3954-4&from=paste&height=401&id=ucabcc682&originHeight=489&originWidth=405&originalType=url&ratio=2&rotation=0&showTitle=false&size=35331&status=done&style=none&taskId=ub474b580-5c5a-4a1f-9c28-cbc155e4ce5&title=&width=332" alt="image.png"><br>请注意，切片只是基础数组的一个子集。</p>
<h4 id="声明和初始化切片"><a href="#声明和初始化切片" class="headerlink" title="声明和初始化切片"></a>声明和初始化切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    months := []<span class="type">string</span>&#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">    fmt.Println(months)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(months))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Capacity:&quot;</span>, <span class="built_in">cap</span>(months))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[January February March April May June July August September October November December]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Capacity: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>请注意目前，切片与数组的区别不大。 可用相同的方式声明这两者。 若要从切片中获取信息，可使用内置函数 len() 和 cap()。 我们将继续使用这些函数来确认切片可具有来自基础数组的后续元素。</p>
<h4 id="切片项"><a href="#切片项" class="headerlink" title="切片项"></a>切片项</h4><p>Go 支持切片运算符 <code>s[i:p]</code>，其中：<br><code>s</code> 表示数组。<br><code>i</code> 表示指向要添加到新切片的基础数组（或另一个切片）的第一个元素的指针。 变量 <code>i</code> 对应于数组 <code>array[i]</code> 中<strong>索引位置</strong><code>**i**</code> 处的元素。 请记住，此元素不一定是基础数组的第一个元素 <code>array[0]</code>。<br><code>p</code> 表示创建新切片时要使用的基础数组中的<strong>元素数目</strong>。 变量 <code>p</code> 对应于可用于新切片的基础数组中的最后一个元素。 可在位置 <code>array[i+1]</code> 找到基础数组中位置 <code>p</code> 处的元素。 请注意，此元素不一定是基础数组的最后一个元素 <code>array[len(array)-1]</code>。<br>如你所见，<strong>切片只能引用元素的子集</strong>。<br>假设你需要 4 个变量来表示一年的每个季度，并且你有一个包含 12 个元素的 <code>months</code> 切片。 下图演示了如何将 <code>months</code> 切片为 4 个新的 <code>quarter</code> 切片：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/755493/1680786723248-4532fadc-9734-42f4-96e8-a129d47af4d0.png#averageHue=%23f7f7f6&clientId=u2357188c-3497-4&from=paste&height=469&id=u8d99c09a&originHeight=516&originWidth=774&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=76127&status=done&style=none&taskId=u1ed1b665-6579-4169-b9d0-9926f7f5631&title=&width=703.6363483854565" alt="image.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    months := []<span class="type">string</span>&#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">    quarter1 := months[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    quarter2 := months[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">    quarter3 := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">    quarter4 := months[<span class="number">9</span>:<span class="number">12</span>]</span><br><span class="line">    fmt.Println(quarter1, <span class="built_in">len</span>(quarter1), <span class="built_in">cap</span>(quarter1))</span><br><span class="line">    fmt.Println(quarter2, <span class="built_in">len</span>(quarter2), <span class="built_in">cap</span>(quarter2))</span><br><span class="line">    fmt.Println(quarter3, <span class="built_in">len</span>(quarter3), <span class="built_in">cap</span>(quarter3))</span><br><span class="line">    fmt.Println(quarter4, <span class="built_in">len</span>(quarter4), <span class="built_in">cap</span>(quarter4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[January February March] <span class="number">3</span> <span class="number">12</span></span><br><span class="line">[April May June] <span class="number">3</span> <span class="number">9</span></span><br><span class="line">[July August September] <span class="number">3</span> <span class="number">6</span></span><br><span class="line">[October November December] <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>切片的长度不变，但容量不同。 我们来了解 <code>quarter2</code> 切片。 声明此切片时，你指出希望切片从位置编号 3 开始，最后一个元素位于位置编号 6。 切片长度为 3 个元素，但容量为 9，原因是基础数组有更多元素或位置可供使用，但对切片而言不可见。 例如，如果你尝试打印类似 <code>fmt.Println(quarter2[3]) </code>的内容，会出现以下错误：<code>panic: runtime error: index out of range [3] with length 3</code>。<br>切片容量仅指切片可扩展的程度。 因此，你可从 <code>quarter2</code> 创建扩展切片，如下例所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	months := []<span class="type">string</span>&#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">	quarter2 := months[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">	quarter2Extended := quarter2[:<span class="number">4</span>]</span><br><span class="line">	fmt.Println(quarter2, <span class="built_in">len</span>(quarter2), <span class="built_in">cap</span>(quarter2))</span><br><span class="line">	fmt.Println(quarter2Extended, <span class="built_in">len</span>(quarter2Extended), <span class="built_in">cap</span>(quarter2Extended))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[April May June] <span class="number">3</span> <span class="number">9</span></span><br><span class="line">[April May June July] <span class="number">4</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>请注意在声明 <code>quarter2Extended</code> 变量时，无需指定初始位置 <code>([:4])</code>。 执行此操作时，Go 会假定你想要切片的第一个位置。 你可对最后一个位置 <code>([1:])</code> 执行相同的操作。 Go 将假定你要引用所有元素，直到切片的最新位置 <code>(len()-1)</code>。</p>
<h4 id="追加项"><a href="#追加项" class="headerlink" title="追加项"></a>追加项</h4><p>Go 提供了内置函数 <code>append(slice, element)</code>，便于你向切片添加元素。 将要修改的切片和要追加的元素作为值发送给该函数。 然后，<code>append</code> 函数会返回一个新的切片，将其存储在变量中。 对于要更改的切片，变量可能相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\tcap=%d\t%v\n&quot;</span>, i, <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       <span class="built_in">cap</span>=<span class="number">1</span>   [<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span>       <span class="built_in">cap</span>=<span class="number">2</span>   [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span>       <span class="built_in">cap</span>=<span class="number">4</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="number">3</span>       <span class="built_in">cap</span>=<span class="number">4</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="number">4</span>       <span class="built_in">cap</span>=<span class="number">8</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="number">5</span>       <span class="built_in">cap</span>=<span class="number">8</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="number">6</span>       <span class="built_in">cap</span>=<span class="number">8</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="number">7</span>       <span class="built_in">cap</span>=<span class="number">8</span>   [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"><span class="number">8</span>       <span class="built_in">cap</span>=<span class="number">16</span>  [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"><span class="number">9</span>       <span class="built_in">cap</span>=<span class="number">16</span>  [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>此输出很有意思。 特别是对于调用 <code>cap()</code> 函数所返回的内容。 一切看起来都很正常，直到第 3 次迭代，此时容量变为 4，切片中只有 3 个元素。 在第 5 次迭代中，容量又变为 8，第 9 次迭代时变为 16。<br>注意到容量输出中的模式了吗？ 当切片容量不足以容纳更多元素时，Go 的容量将翻倍。 它将新建一个具有新容量的基础数组。 无需执行任何操作即可使容量增加。 Go 会自动扩充容量。 需要谨慎操作。 有时，一个切片具有的容量可能比它需要的多得多，这样你将会浪费内存。</p>
<h4 id="删除项"><a href="#删除项" class="headerlink" title="删除项"></a>删除项</h4><p>Go 没有内置函数用于从切片中删除元素。 可使用上述切片运算符 <code>s[i:p]</code> 来新建一个仅包含所需元素的切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    letters := []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;</span><br><span class="line">    remove := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> remove &lt; <span class="built_in">len</span>(letters) &#123;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;Before&quot;</span>, letters, <span class="string">&quot;Remove &quot;</span>, letters[remove])</span><br><span class="line"></span><br><span class="line">		letters = <span class="built_in">append</span>(letters[:remove], letters[remove+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;After&quot;</span>, letters)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before [A B C D E]</span><br><span class="line">After [A B D E]</span><br></pre></td></tr></table></figure>

<p>此代码会从切片中删除元素。 它用切片中的下一个元素替换要删除的元素，如果删除的是最后一个元素，则不替换。<br>另一种方法是创建切片的新副本。</p>
<h4 id="创建切片的副本-深浅拷贝"><a href="#创建切片的副本-深浅拷贝" class="headerlink" title="创建切片的副本[深浅拷贝]"></a>创建切片的副本[深浅拷贝]</h4><p>Go 具有内置函数 <code>copy(dst, src []Type)</code> 用于创建切片的副本。 你需要发送目标切片和源切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice2, letters[<span class="number">1</span>:<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>为何要创建副本？ 更改切片中的元素时，基础数组将随之更改。 引用该基础数组的任何其他切片都会受到影响。 让我们在代码中看看此过程，然后创建一个切片副本来解决此问题。<br>使用下述代码确认切片指向数组，而你在切片中所做的每个更改都会影响基础数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    letters := []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Before&quot;</span>, letters)</span><br><span class="line"></span><br><span class="line">    slice1 := letters[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    slice2 := letters[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    slice1[<span class="number">1</span>] = <span class="string">&quot;Z&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;After&quot;</span>, letters)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Slice2&quot;</span>, slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before [A B C D E]</span><br><span class="line">After [A Z C D E]</span><br><span class="line">Slice2 [Z C D]</span><br></pre></td></tr></table></figure>

<p>请注意对 <code>slice1</code> 所做的更改如何影响 <code>letters</code> 数组和 <code>slice2</code>。 可在输出中看到字母 B 已替换为 Z，它会影响指向 letters 数组的每个切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	letters := []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Before&quot;</span>, letters)</span><br><span class="line"></span><br><span class="line">	slice1 := letters[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	slice2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="built_in">copy</span>(slice2, letters[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">	slice1[<span class="number">1</span>] = <span class="string">&quot;Z&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;After&quot;</span>, letters)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Slice2&quot;</span>, slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before [A B C D E]</span><br><span class="line">After [A Z C D E]</span><br><span class="line">Slice2 [B C D]</span><br></pre></td></tr></table></figure>

<p>请注意 <code>slice1</code> 中的更改如何影响基础数组，但它并未影响新的 <code>slice2</code>。</p>
<h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h3><p>大体上来说，Go 中的映射是一个哈希表，是键值对的集合。 映射中所有的键都必须具有相同的类型，它们的值也是如此。 不过，可对键和值使用不同的类型。 例如，键可以是数字，值可以是字符串。 若要访问映射中的特定项，可引用该项的键。</p>
<h4 id="声明和初始化映射"><a href="#声明和初始化映射" class="headerlink" title="声明和初始化映射"></a>声明和初始化映射</h4><p>若要声明映射，需要使用 <code>map</code> 关键字。 然后，定义键和值类型，如下所示：<code>map[T]T</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	studentAge := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;john&quot;</span>: <span class="number">32</span>,</span><br><span class="line">		<span class="string">&quot;bob&quot;</span>:  <span class="number">32</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(studentAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[bob:<span class="number">31</span> john:<span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<p>如果不想使用项来初始化映射，可使用内置函数 <code>make()</code> 在上一部分创建切片。 可使用以下代码创建空映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>映射是动态的。 创建项后，可添加、访问或删除这些项。 让我们来了解这些操作。</p>
<h4 id="添加项"><a href="#添加项" class="headerlink" title="添加项"></a>添加项</h4><p>要添加项，无需像对切片一样使用内置函数。 映射更加简单。 你只需定义键和值即可。 如果没有键值对，则该项会添加到映射中。<br>让我们使用 <code>make</code> 函数重写之前用于创建映射的代码。 然后，将项添加到映射中。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">    fmt.Println(studentsAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[bob:<span class="number">31</span> john:<span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<p>请注意，我们已向已初始化的映射添加了项。 但如果尝试使用 nil 映射执行相同操作，会出现错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> studentsAge <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">    fmt.Println(studentsAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/johndoe/<span class="keyword">go</span>/src/helloworld/main.<span class="keyword">go</span>:<span class="number">7</span> +<span class="number">0x4f</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>若要避免在将项添加到映射时出现问题，请确保使用 <code>make</code> 函数（如我们在上述代码片段中所示）创建一个空映射（而不是 nil 映射）。 此规则仅适用于添加项的情况。 如果在 nil 映射中运行查找、删除或循环操作，Go 不会执行 panic。</p>
<h4 id="访问项"><a href="#访问项" class="headerlink" title="访问项"></a>访问项</h4><p>若要访问映射中的项，可使用常用的下标表示法 <code>m[key]</code>，就像操作数组或切片一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s age is&quot;</span>, studentsAge[<span class="string">&quot;bob&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在映射中使用下标表示法时，即使映射中没有键，你也总会获得响应。 当你访问不存在的项时，Go 不会执行 panic。 此时，你会获得默认值。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Christy&#x27;s age is&quot;</span>, studentsAge[<span class="string">&quot;christy&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Christy<span class="string">&#x27;s age is 0</span></span><br></pre></td></tr></table></figure>

<p>在很多情况下，访问映射中没有的项时 Go 不会返回错误，这是正常的。 但有时需要知道某个项是否存在。 在 Go 中，映射的下标表示法可生成两个值。 第一个是项的值。 第二个是指示键是否存在的布尔型标志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    age, exist := studentsAge[<span class="string">&quot;christy&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> exist &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Christy&#x27;s age is&quot;</span>, age)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Christy&#x27;s age couldn&#x27;t be found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Christy<span class="string">&#x27;s age couldn&#x27;</span>t be found</span><br></pre></td></tr></table></figure>

<p>使用第二个代码片段检查映射中的键在你访问之前是否存在。</p>
<h4 id="删除项-1"><a href="#删除项-1" class="headerlink" title="删除项"></a>删除项</h4><p>若要从映射中删除项，请使用内置函数 <code>delete()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">    <span class="built_in">delete</span>(studentsAge, <span class="string">&quot;john&quot;</span>)</span><br><span class="line">    fmt.Println(studentsAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[bob:<span class="number">31</span>]</span><br></pre></td></tr></table></figure>

<h4 id="映射中的循环"><a href="#映射中的循环" class="headerlink" title="映射中的循环"></a>映射中的循环</h4><p>最后，让我们看看如何在映射中进行循环来以编程方式访问其所有的项。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	studentsAge[<span class="string">&quot;John&quot;</span>] = <span class="number">32</span></span><br><span class="line">	studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line">	<span class="keyword">for</span> name, age := <span class="keyword">range</span> studentsAge &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john    <span class="number">32</span></span><br><span class="line">bob     <span class="number">31</span></span><br></pre></td></tr></table></figure>

<p>请注意可如何将键和值信息存储在不同的变量中。 在本例中，我们将键保存在 <code>name</code> 变量中，将值保存在 <code>age</code> 变量中。 因此，<code>range</code> 会首先生成项的键，然后再生成该项的值。 可使用 <code>_</code> 变量忽略其中任何一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, age := <span class="keyword">range</span> studentsAge &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Ages %d\n&quot;</span>, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使在本例中用这种方式打印年龄没有意义，但存在你无需知道项的键的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    studentsAge := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    studentsAge[<span class="string">&quot;john&quot;</span>] = <span class="number">32</span></span><br><span class="line">    studentsAge[<span class="string">&quot;bob&quot;</span>] = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name := <span class="keyword">range</span> studentsAge &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Names %s\n&quot;</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h4><p>map在Go语言并发编程中,如果仅用于读取数据时候是安全的，但是在读写操作的时候是不安全的，在Go语言1.9版本后提供了一种并发安全的，sync.Map是Go语言提供的内置map，不同于基本的map数据类型，所以不能像操作基本map那样的方式操作数据，他提供了特有的方法，不需要初始化操作实现增删改查的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明sync.Map</span></span><br><span class="line"><span class="keyword">var</span> syncmap sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Store方法将键值对保存到sync.Map</span></span><br><span class="line">    syncmap.Store(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">97</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;lisi&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    syncmap.Store(<span class="string">&quot;wangmazi&quot;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load方法获取sync.Map 键所对应的值</span></span><br><span class="line">    fmt.Println(syncmap.Load(<span class="string">&quot;lisi&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete方法键删除对应的键值对</span></span><br><span class="line">    syncmap.Delete(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Range遍历所有sync.Map中的键值对</span></span><br><span class="line">    syncmap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h2><p> 通常情况下，默认包是 <code>main</code> 包。<br>换当使用 <code>main</code> 包时，程序将生成独立的可执行文件。 但当程序非是 <code>main</code> 包的一部分时，Go 不会生成二进制文件。 它生成包存档文件（具有 <code>.a</code> 扩展名的文件）。<br>在 Go 中，包名称需遵循约定。 包使用其导入路径的最后一部分作为名称。 例如，Go 标准库包含名为 <code>math/cmplx</code> 的包，该包提供用于处理复数的有用代码。 此包的导入路径为 <code>math/cmplx</code>，导入包的方式如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/cmplx&quot;</span></span><br></pre></td></tr></table></figure>

<p>若要引用包中的对象，请使用包名称 <code>cmplx</code>，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmplx.Inf()</span><br></pre></td></tr></table></figure>

<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>案例：在 <code>$GOPATH/src</code>下创建目录<code>calculator</code>和名为 <code>sum.go</code> 的文件，然后初始化此文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculator</span><br></pre></td></tr></table></figure>

<p>现在可以开始编写包的函数和变量。<br>不同于其他编程语言，Go 不会提供 <code>public</code> 或 <code>private</code> 关键字，以指示是否可以从包的内外部调用变量或函数。 但 Go 须遵循以下两个简单规则：</p>
<ul>
<li><strong>如需将某些内容设为专用内容，请以小写字母开始。</strong></li>
<li><strong>如需将某些内容设为公共内容，请以大写字母开始。</strong></li>
</ul>
<p>补全代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculator</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logMessage = <span class="string">&quot;[LOG]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Version = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internalSum</span><span class="params">(number <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> number<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(number1, number2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> number1 + number2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看一下该代码中的一些事项：</p>
<ul>
<li>只能从包内调用 <code>logMessage</code> 变量。</li>
<li>可以从任何位置访问 <code>Version</code> 变量。 建议你添加注释来描述此变量的用途。 （此描述适用于包的任何用户。）</li>
<li>只能从包内调用 <code>internalSum</code> 函数。</li>
<li>可以从任何位置访问 <code>Sum</code> 函数。 建议你添加注释来描述此函数的用途。</li>
</ul>
<p>若要确认一切正常，可在 <code>calculator</code> 目录中运行 <code>go build</code> 命令。 如果执行此操作，请注意系统不会生成可执行的二进制文件。</p>
<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>Go 模块通常包含可提供相关功能的包。 包的模块还指定了 Go 运行你组合在一起的代码所需的上下文环境。 此上下文信息包括编写代码时所用的 Go 版本。<br>此外，模块还有助于其他开发人员引用代码的特定版本，并更轻松地处理依赖项。 另一个优点是，我们的程序源代码无需严格存在于 <code>$GOPATH/src</code> 目录中。 如果释放该限制，则可以更方便地在其他项目中同时使用不同包版本。<br>若要为 calculator 包创建模块，请在根目录 <code>($GOPATH/src/calculator)</code> 中运行以下命令</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init github.com/myuser/calculator</span><br></pre></td></tr></table></figure>

<p>运行此命令后，<code>github.com/myuser/calculator</code> 就会变成模块的名称。 在其他程序中，你将使用该名称进行引用。 命令还会创建一个名为 <code>go.mod</code> 的新文件。 最后，树目录现会如下列目录所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  calculator/</span><br><span class="line">    go.mod</span><br><span class="line">    sum.go</span><br></pre></td></tr></table></figure>

<p><code>go.mod</code> 内容应该如下代码所示： （Go 版本可能不同。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/myuser/calculator</span><br><span class="line"></span><br><span class="line">go 1.20</span><br></pre></td></tr></table></figure>

<h2 id="引用本地包（模块）"><a href="#引用本地包（模块）" class="headerlink" title="引用本地包（模块）"></a>引用本地包（模块）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/myuser/calculator&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    total := calculator.Sum(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Version: &quot;</span>, calculator.Version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果立即尝试运行程序，它将不起任何作用。 你需要告诉 Go，你会使用模块来引用其他包。 为此，请在 <code>$GOPATH/src/helloworld</code> 目录中运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init helloworld</span><br></pre></td></tr></table></figure>

<p>此举会创建一个新的 <code>mod</code>文件，文件目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  calculator/</span><br><span class="line">    go.mod</span><br><span class="line">    sum.go</span><br><span class="line">  helloworld/</span><br><span class="line">    go.mod</span><br><span class="line">    main.go</span><br></pre></td></tr></table></figure>

<p>由于你引用的是该模块的本地副本，因此你需要通知 Go 不要使用远程位置。 因此，你需要手动修改 <code>go.mod</code>文件，使其包含引用，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/myuser/calculator v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace github.com/myuser/calculator =&gt; ../calculator</span><br></pre></td></tr></table></figure>

<p><code>replace</code> 关键字指定使用本地目录，而不是模块的远程位置。 在这种情况下，由于 <code>helloworld</code> 和 <code>calculator</code> 程序在 <code>$GOPATH/src</code> 中，因此位置只能是 <code>../calculator</code>。 如果模块源位于不同的位置，请在此处定义本地路径。</p>
<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>如果想要将 <code>calculator</code> 包发布到 GitHub 帐户，则需要创建一个名为 <code>calculator</code> 的存储库。 URL 应与下述网址类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/myuser/calculator</span><br></pre></td></tr></table></figure>

<p>将通过标记存储库来对包进行版本化，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.1.0</span><br><span class="line">git push origin v0.1.0</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/myuser/calculator&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="引用外部（第三方）包"><a href="#引用外部（第三方）包" class="headerlink" title="引用外部（第三方）包"></a>引用外部（第三方）包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/myuser/calculator&quot;</span></span><br><span class="line">    <span class="string">&quot;rsc.io/quote&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    total := calculator.Sum(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Version: &quot;</span>, calculator.Version)</span><br><span class="line">    fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后需要更新 <code>go mod</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/myuser/calculator v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">	rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c <span class="comment">// indirect</span></span><br><span class="line">	rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace github.com/myuser/calculator =&gt; ../calculator</span><br></pre></td></tr></table></figure>

<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="if-x2F-else-条件表达式"><a href="#if-x2F-else-条件表达式" class="headerlink" title="if&#x2F;else 条件表达式"></a>if&#x2F;else 条件表达式</h2><p>与其他编程语言不同的是，在 Go 中，你不需要在条件中使用括号。 <code>else</code> 子句可选。 但是，大括号仍然是必需的。 此外，为了减少行，Go 不支持三元 if 语句，因此每次都需要编写完整的 if 语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">27</span></span><br><span class="line">	<span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(x, <span class="string">&quot;is even&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">givemeanumber</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num := givemeanumber(); num &lt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has only one digit&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在此代码中，<code>num</code> 变量存储从 <code>givemeanumber()</code> 函数返回的值，并且该变量在所有 <code>if</code>分支中可用。 </p>
<h2 id="switch-控制器"><a href="#switch-控制器" class="headerlink" title="switch 控制器"></a>switch 控制器</h2><p>像其他编程语言一样，Go 支持 <code>switch</code> 语句。 可以使用 <code>switch</code> 语句来避免链接多个 if 语句。 使用 <code>switch</code> 语句，就不需维护和读取包含多个 <code>if</code> 语句的代码。 这些语句还可以让复杂的条件更易于构造。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sec := time.Now().Unix()</span><br><span class="line">	rand.Seed(sec)</span><br><span class="line">	i := rand.Int31n(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;i is :&quot;</span>, i)</span><br><span class="line">	<span class="keyword">switch</span> i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		fmt.Print(<span class="string">&quot;zero...&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Print(<span class="string">&quot;one...&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Print(<span class="string">&quot;two...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多表达式匹配"><a href="#多表达式匹配" class="headerlink" title="多表达式匹配"></a>多表达式匹配</h3><p>如果希望 <code>case</code> 语句包含多个表达式，请使用逗号 <code>,</code> 来分隔表达式。 此方法可避免代码重复。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">location</span><span class="params">(city <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> region <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> continent <span class="type">string</span></span><br><span class="line">    <span class="keyword">switch</span> city &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Delhi&quot;</span>, <span class="string">&quot;Hyderabad&quot;</span>, <span class="string">&quot;Mumbai&quot;</span>, <span class="string">&quot;Chennai&quot;</span>, <span class="string">&quot;Kochi&quot;</span>:</span><br><span class="line">        region, continent = <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Asia&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Lafayette&quot;</span>, <span class="string">&quot;Louisville&quot;</span>, <span class="string">&quot;Boulder&quot;</span>:</span><br><span class="line">        region, continent = <span class="string">&quot;Colorado&quot;</span>, <span class="string">&quot;USA&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Irvine&quot;</span>, <span class="string">&quot;Los Angeles&quot;</span>, <span class="string">&quot;San Diego&quot;</span>:</span><br><span class="line">        region, continent = <span class="string">&quot;California&quot;</span>, <span class="string">&quot;USA&quot;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        region, continent = <span class="string">&quot;Unknown&quot;</span>, <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> region, continent</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    region, continent := location(<span class="string">&quot;Irvine&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;John works in %s, %s\n&quot;</span>, region, continent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p><code>switch</code> 还可以调用函数。 在该函数中，可以针对可能的返回值编写 <code>case</code> 语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> time.Now().Weekday().String() &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;It&#x27;s time to learn some Go.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;It&#x27;s the weekend, time to rest!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(time.Now().Weekday().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以从 <code>case</code> 语句调用函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> email = regexp.MustCompile(<span class="string">`^[^@]+@[^@.]+\.[^@.]+`</span>)</span><br><span class="line">	<span class="keyword">var</span> phone = regexp.MustCompile(<span class="string">`^[(]?[0-9][0-9][0-9][). \-]*[0-9][0-9][0-9][.\-]?[0-9][0-9][0-9][0-9]`</span>)</span><br><span class="line"></span><br><span class="line">	contact := <span class="string">&quot;foo@bar.com&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> email.MatchString(contact):</span><br><span class="line">		fmt.Println(contact, <span class="string">&quot;is an email&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> phone.MatchString(contact):</span><br><span class="line">		fmt.Println(contact, <span class="string">&quot;is a phone number&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(contact, <span class="string">&quot;is not recognized&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略条件"><a href="#省略条件" class="headerlink" title="省略条件"></a>省略条件</h3><p>在 Go 中，可以在 <code>switch</code>语句中省略条件，就像在 <code>if</code> 语句中那样。 此模式类似于 <code>true</code> 值，就像强制 <code>switch</code> 语句一直运行一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    r := rand.Float64()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r &gt; <span class="number">0.1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Common case, 90% of the time&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;10% of the time&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使逻辑进入到下一个-case"><a href="#使逻辑进入到下一个-case" class="headerlink" title="使逻辑进入到下一个 case"></a>使逻辑进入到下一个 case</h3><p>在某些编程语言中，你会在每个 <code>case</code> 语句末尾写一个 <code>break</code> 关键字。 但在 Go 中，当逻辑进入某个 case 时，它会退出 <code>switch</code> 块，除非你显式停止它。 若要使逻辑进入到下一个紧邻的 <code>case</code>，请使用 <code>fallthrough</code> 关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num := <span class="number">15</span>; &#123;</span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">50</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is less than 50\n&quot;</span>, num)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> num &gt; <span class="number">100</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is greater than 100\n&quot;</span>, num)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">200</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is less than 200&quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，由于 <code>num</code> 为 15（小于 50），因此它与第一个 <code>case</code> 匹配。 但是，<code>num</code> 不大于 100。 由于第一个 case 语句包含 <code>fallthrough</code> 关键字，因此逻辑会立即转到下一个 <code>case</code> 语句，而不会对该 <code>case</code> 进行验证。 因此，在使用 <code>fallthrough</code> 关键字时必须谨慎。 该代码产生的行为可能不是你想要的。</p>
<h2 id="for-循环表达式"><a href="#for-循环表达式" class="headerlink" title="for 循环表达式"></a>for 循环表达式</h2><p>Go 只使用一个循环构造，即 <code>for</code> 循环。与 <code>if</code> 语句和 <code>switch</code> 语句一样，<code>for</code> 循环表达式不需要括号。 但是，大括号是必需的。<br>分号 <code>;</code> 分隔 <code>for</code> 循环的三个组件：</p>
<ul>
<li>在第一次迭代之前执行的初始语句（可选）。</li>
<li>在每次迭代之前计算的条件表达式。 该条件为 <code>false</code> 时，循环会停止。</li>
<li>在每次迭代结束时执行的后处理语句（可选）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;sum of 1..100 is&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空的预处理语句和后处理语句"><a href="#空的预处理语句和后处理语句" class="headerlink" title="空的预处理语句和后处理语句"></a>空的预处理语句和后处理语句</h3><p>只要 <code>num</code> 变量保存的值与 5 不同，程序就会输出一个随机数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">int64</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">5</span> &#123;</span><br><span class="line">        num = rand.Int63n(<span class="number">15</span>)</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无限循环和-break-语句"><a href="#无限循环和-break-语句" class="headerlink" title="无限循环和 break 语句"></a>无限循环和 break 语句</h3><p>在这种情况下，你不编写条件表达式，也不编写预处理语句或后处理语句， 而是采取退出循环的方式进行编写。 否则，逻辑永远都不会退出。 若要使逻辑退出循环，请使用 <code>break</code> 关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int32</span></span><br><span class="line">	sec := time.Now().Unix()</span><br><span class="line">	rand.Seed(sec)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Print(<span class="string">&quot;Writing inside the loop...&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> num = rand.Int31n(<span class="number">10</span>); num == <span class="number">5</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;finish!&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Continue-语句"><a href="#Continue-语句" class="headerlink" title="Continue 语句"></a>Continue 语句</h3><p>在 Go 中，可以使用 <code>continue</code> 关键字跳过循环的当前迭代。 例如，可以使用此关键字在循环继续之前运行验证。 也可以在编写无限循环并需要等待资源变得可用时使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num := <span class="number">1</span>; num &lt;= <span class="number">100</span>; num++ &#123;</span><br><span class="line">		<span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The sum of 1 to 100, but excluding numbers divisible by 5, is&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer-x2F-panic-x2F-recover函数"><a href="#defer-x2F-panic-x2F-recover函数" class="headerlink" title="defer&#x2F;panic&#x2F;recover函数"></a>defer&#x2F;panic&#x2F;recover函数</h2><p>Go 特有的一些控制流：<code>defer</code>、<code>panic</code> 和 <code>recover</code></p>
<h3 id="defer-函数"><a href="#defer-函数" class="headerlink" title="defer 函数"></a>defer 函数</h3><p>在 Go 中，<code>defer</code> 语句会推迟函数（包括任何参数）的运行，直到包含 <code>defer</code> 语句的<strong>函数</strong>完成。 通常情况下，当你想要避免忘记任务（例如关闭文件或运行清理进程）时，可以推迟某个函数的运行。<br>可以根据需要推迟任意多个函数。 <code>defer</code> 语句按逆序运行，先运行最后一个，最后运行第一个。<br>有点像<strong>栈</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;deferred&quot;</span>, -i)</span><br><span class="line">        fmt.Println(<span class="string">&quot;regular&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regular <span class="number">1</span></span><br><span class="line">regular <span class="number">2</span></span><br><span class="line">regular <span class="number">3</span></span><br><span class="line">regular <span class="number">4</span></span><br><span class="line">deferred <span class="number">-4</span></span><br><span class="line">deferred <span class="number">-3</span></span><br><span class="line">deferred <span class="number">-2</span></span><br><span class="line">deferred <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><code>defer</code> 函数的一个典型用例是在使用完文件后将其关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newfile, <span class="type">error</span> := os.Create(<span class="string">&quot;learnGo.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">error</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error: Could not create file.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newfile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, <span class="type">error</span> = io.WriteString(newfile, <span class="string">&quot;Learning Go!&quot;</span>); <span class="type">error</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">	    fmt.Println(<span class="string">&quot;Error: Could not write to file.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newfile.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建或打开某个文件后，可以推迟 <code>.Close()</code> 函数的执行，以免在你完成后忘记关闭该文件。</p>
<h3 id="panic-函数"><a href="#panic-函数" class="headerlink" title="panic 函数"></a>panic 函数</h3><p>运行时错误会使 Go 程序崩溃，例如尝试通过使用超出范围的索引或取消引用 nil 指针来访问数组。 你也可以强制程序崩溃。<br>内置 <code>panic()</code> 函数可以停止 Go 程序中的正常控制流。 当你使用 <code>panic</code> 调用时，任何延迟的函数调用都将正常运行。 进程会在堆栈中继续，直到所有函数都返回。 然后，程序会崩溃并记录日志消息。 此消息包含错误信息和堆栈跟踪，有助于诊断问题的根本原因。<br>调用 <code>panic()</code> 函数时，可以添加任何值作为参数。 通常，你会发送一条错误消息，说明为什么会进入紧急状态。<br>例如，下面的代码将 <code>panic</code> 和 <code>defer</code> 函数组合在一起。 尝试运行此代码以了解控制流的中断。 请注意，清理过程仍会运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">highlow</span><span class="params">(high <span class="type">int</span>, low <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> high &lt; low &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panic!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;highlow() low greater than high&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Deferred: highlow(&quot;</span>, high, <span class="string">&quot;,&quot;</span>, low, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Call: highlow(&quot;</span>, high, <span class="string">&quot;,&quot;</span>, low, <span class="string">&quot;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    highlow(high, low + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    highlow(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Program finished successfully!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">0</span> )</span><br><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">1</span> )</span><br><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">2</span> )</span><br><span class="line">Panic!</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">2</span> )</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">1</span> )</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">0</span> )</span><br><span class="line"><span class="built_in">panic</span>: highlow() low greater than high</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.highlow(<span class="number">0x2</span>, <span class="number">0x3</span>)</span><br><span class="line">	/tmp/sandbox/prog.<span class="keyword">go</span>:<span class="number">13</span> +<span class="number">0x34c</span></span><br><span class="line">main.highlow(<span class="number">0x2</span>, <span class="number">0x2</span>)</span><br><span class="line">	/tmp/sandbox/prog.<span class="keyword">go</span>:<span class="number">18</span> +<span class="number">0x298</span></span><br><span class="line">main.highlow(<span class="number">0x2</span>, <span class="number">0x1</span>)</span><br><span class="line">	/tmp/sandbox/prog.<span class="keyword">go</span>:<span class="number">18</span> +<span class="number">0x298</span></span><br><span class="line">main.highlow(<span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">	/tmp/sandbox/prog.<span class="keyword">go</span>:<span class="number">18</span> +<span class="number">0x298</span></span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox/prog.<span class="keyword">go</span>:<span class="number">6</span> +<span class="number">0x37</span></span><br><span class="line"></span><br><span class="line">Program exited: status <span class="number">2.</span></span><br></pre></td></tr></table></figure>

<p>下面是运行代码时会发生的情况：</p>
<ol>
<li>一切正常运行。 程序将输出传递到 <code>highlow()</code> 函数中的高值和低值。</li>
<li>如果 <code>low</code> 的值大于 <code>high</code> 的值，则程序会崩溃。 会显示<code>“Panic!”</code>消息。 此时，控制流中断，所有推迟的函数都开始输出<code>“Deferred...”</code>消息。</li>
<li>程序崩溃，并显示完整的堆栈跟踪。 不会显示“Program finished successfully!”消息。</li>
</ol>
<p>在发生未预料到的严重错误时，系统通常会运行对 <code>panic()</code> 函数的调用。 若要避免程序崩溃，可以使用名为 <code>recover()</code> 的另一个函数。</p>
<h3 id="recover-函数【类异常处理】"><a href="#recover-函数【类异常处理】" class="headerlink" title="recover 函数【类异常处理】"></a>recover 函数【类异常处理】</h3><p>有时，你可能想要避免程序崩溃，改为在内部报告错误。 或者，你可能想要先清理混乱情况，然后再让程序崩溃。 例如，你可能想要关闭与某个资源的连接，以免出现更多问题。<br>Go 提供内置 <code>recover()</code> 函数，让你可以在程序崩溃之后重新获得控制权。 只会在你同时调用 <code>defer</code> 的函数中调用 <code>recover</code>。 如果调用 <code>recover()</code> 函数，则在正常运行的情况下，它会返回 <code>nil</code>，没有任何其他作用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		handler := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> handler != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;main(): recover&quot;</span>, handler)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	highlow(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Program finished successfully!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">0</span> )</span><br><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">1</span> )</span><br><span class="line">Call: highlow( <span class="number">2</span> , <span class="number">2</span> )</span><br><span class="line">Panic!</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">2</span> )</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">1</span> )</span><br><span class="line">Deferred: highlow( <span class="number">2</span> , <span class="number">0</span> )</span><br><span class="line">main(): <span class="built_in">recover</span> from <span class="built_in">panic</span> highlow() low greater than high</span><br><span class="line"></span><br><span class="line">Program exited.</span><br></pre></td></tr></table></figure>

<p><code>panic</code> 和 <code>recover</code> 函数的组合是 Go 处理异常的惯用方式。 其他编程语言使用 <code>try/catch</code> 块。 Go 首选此处所述的方法。Go 不支持异常。</p>
<h1 id="错误处理和日志记录"><a href="#错误处理和日志记录" class="headerlink" title="错误处理和日志记录"></a>错误处理和日志记录</h1><p>有时，你所编写的程序的行为不符合预期。 有时存在一些你无法控制的外部因素，例如其他进程阻止了文件，或者尝试访问不再可用的内存地址。 失败只是程序可能具有的另一种行为。 如果能预见这些失败，就能在它们出现时解决问题。<br>正如你所了解的那样，Go 的异常处理方法与其他语言不同，其错误处理过程也是如此。 在 Go 中，可能失败的函数应始终返回一个额外值，以便你能够成功预测和管理失败。 例如，你可以运行默认行为并记录尽可能多的信息以再现并修复问题。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 的错误处理方法只是一种只需要 <code>if</code> 和 <code>return</code> 语句的控制流机制。 例如，在调用函数以从 <code>employee</code> 对象获取信息时，可能需要了解该员工是否存在。 Go 处理此类预期错误的一贯方法如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employee, err := getInformation(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Something is wrong. Do something.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>getInformation</code> 函数返回了 <code>employee</code> 结构，还返回了错误作为第二个值。 该错误可能为 <code>nil</code>。 如果错误为 <code>nil</code>，则表示成功。 如果错误不是 <code>nil</code>，则表示失败。 非 <code>nil</code> 错误附带一条错误消息，你可以打印该错误消息，也可以记录该消息（更可取）。 <strong>这是在 Go 中处理错误的方式</strong>。 下一部分将介绍一些其他策略。<br>你可能会注意到，Go 中的错误处理要求你更加关注如何报告和处理错误。 这正是问题的关键。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int</span></span><br><span class="line">    FirstName <span class="type">string</span></span><br><span class="line">    LastName  <span class="type">string</span></span><br><span class="line">    Address   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    employee, err := getInformation(<span class="number">1001</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Something is wrong. Do something.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Print(employee)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInformation</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    employee, err := apiCallEmployee(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> employee, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apiCallEmployee</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    employee := Employee&#123;LastName: <span class="string">&quot;Doe&quot;</span>, FirstName: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;employee, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从现在开始，我们将重点介绍如何修改 <code>getInformation</code>、<code>apiCallEmployee</code> 和 <code>main</code> 函数，以展示如何处理错误。</p>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p><strong>当函数返回错误时，该错误通常是最后一个返回值</strong>。 正如上一部分所介绍的那样，调用方负责检查是否存在错误并处理错误。 因此，一个常见策略是继续使用该模式在子例程中传播错误。 例如，子例程（如上一示例中的 <code>getInformation</code>）可能会将错误返回给调用方，而不执行其他任何操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInformation</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    employee, err := apiCallEmployee(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// Simply return the error to the caller.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> employee, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能还需要在传播错误之前添加更多信息。 为此，可以使用 <code>fmt.Errorf()</code> 函数，该函数与我们之前看到的函数类似，但它返回一个错误。 例如，你可以向错误添加更多上下文，但仍返回原始错误.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInformation</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    employee, err := apiCallEmployee(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Got an error when getting the employee information: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> employee, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种策略是在错误为暂时性错误时运行重试逻辑。 例如，可以使用重试策略调用函数三次并等待两秒钟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInformation</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; tries &lt; <span class="number">3</span>; tries++ &#123;</span><br><span class="line">        employee, err := apiCallEmployee(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> employee, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;Server is not responding, retrying ...&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;server has failed to respond to get the employee information&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，可以记录错误并对最终用户隐藏任何实现详细信息，而不是将错误打印到控制台。 我们将在下一模块介绍日志记录。 现在，让我们看看如何创建和使用自定义错误。</p>
<h3 id="创建可重用的错误"><a href="#创建可重用的错误" class="headerlink" title="创建可重用的错误"></a>创建可重用的错误</h3><p>有时错误消息数会增加，你需要维持秩序。 或者，你可能需要为要重用的常见错误消息创建一个库。 在 Go 中，你可以使用 <code>errors.New()</code> 函数创建错误并在若干部分中重复使用这些错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;Employee not found!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInformation</span><span class="params">(id <span class="type">int</span>)</span></span> (*Employee, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> id != <span class="number">1001</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">    &#125;</span><br><span class="line">    employee := Employee&#123;LastName: <span class="string">&quot;Doe&quot;</span>, FirstName: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;employee, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getInformation</code> 函数的代码外观更优美，而且如果需要更改错误消息，只需在一个位置更改即可。 另请注意，惯例是为错误变量添加 <code>Err</code> 前缀。<br>最后，如果你具有错误变量，则在处理调用方函数中的错误时可以更具体。 <code>errors.Is()</code> 函数允许你比较获得的错误的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">employee, err := getInformation(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;NOT FOUND: %v\n&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Print(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用于错误处理的推荐做法"><a href="#用于错误处理的推荐做法" class="headerlink" title="用于错误处理的推荐做法"></a>用于错误处理的推荐做法</h3><p>在 Go 中处理错误时，请记住下面一些推荐做法：</p>
<ul>
<li>始终检查是否存在错误，即使预期不存在。 然后正确处理它们，以免向最终用户公开不必要的信息。</li>
<li>在错误消息中包含一个前缀，以便了解错误的来源。 例如，可以包含包和函数的名称。</li>
<li>创建尽可能多的可重用错误变量。</li>
<li>了解使用返回错误和 <code>panic</code> 之间的差异。 不能执行其他操作时再使用 <code>panic</code>。 例如，如果某个依赖项未准备就绪，则程序运行无意义（除非你想要运行默认行为）。</li>
<li>在记录错误时记录尽可能多的详细信息，并打印出最终用户能够理解的错误。</li>
</ul>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>日志在程序中发挥着重要作用，因为它们是在出现问题时你可以检查的信息源。 通常，发生错误时，最终用户只会看到一条消息，指示程序出现问题。 从开发人员的角度来看，我们需要简单错误消息以外的更多信息。 这主要是因为我们想要再现该问题以编写适当的修补程序。 </p>
<h3 id="log-包"><a href="#log-包" class="headerlink" title="log 包"></a>log 包</h3><p>对于初学者，Go 提供了一个用于处理日志的简单标准包。 可以像使用 <code>fmt</code> 包一样使用此包。 该标准包不提供日志级别，且不允许为每个包配置单独的记录器。 如果需要编写更复杂的日志记录配置，可以使用记录框架执行此操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;Hey, I&#x27;m a log!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>/<span class="number">04</span>/<span class="number">07</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">06</span> Hey, I<span class="string">&#x27;m a log!</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>log.Print()</code> 函数将日期和时间添加为日志消息的前缀。 你可以通过使用 <code>fmt.Print()</code> 获得相同的行为，但使用 <code>log</code> 包还能执行其他操作，例如将日志发送到文件。<br>可以使用 <code>log.Fatal()</code> 函数记录错误并结束程序，就像使用 <code>os.Exit(1)</code> 一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Hey, I&#x27;m an error log!&quot;</span>)</span><br><span class="line">    fmt.Print(<span class="string">&quot;Can you see me?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>/<span class="number">04</span>/<span class="number">07</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">14</span> Hey, I<span class="string">&#x27;m a log!</span></span><br><span class="line"><span class="string">exit status 1</span></span><br></pre></td></tr></table></figure>

<p>注意最后一行 <code>fmt.Print(&quot;Can you see me?&quot;)</code> 未运行。 这是因为 <code>log.Fatal()</code> 函数调用停止了该程序。 在使用 <code>log.Panic()</code> 函数时会出现类似行为，该函数也调用 <code>panic()</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Panic(<span class="string">&quot;Hey, I&#x27;m an error log!&quot;</span>)</span><br><span class="line">    fmt.Print(<span class="string">&quot;Can you see me?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: Hey, I<span class="string">&#x27;m an error log!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">goroutine 1 [running]:</span></span><br><span class="line"><span class="string">log.Panic(&#123;0xc0000bff50?, 0xc0000bff70?, 0xa65859?&#125;)</span></span><br><span class="line"><span class="string">        C:/Program Files/Go/src/log/log.go:384 +0x65</span></span><br><span class="line"><span class="string">main.main()</span></span><br><span class="line"><span class="string">        E:/Work_HK/Code/GoProjects/src/helloworld/main.go:9 +0x48</span></span><br><span class="line"><span class="string">exit status 2</span></span><br></pre></td></tr></table></figure>

<p>你仍获得日志消息，但现在还会获得错误堆栈跟踪。<br>另一重要函数是 <code>log.SetPrefix()</code>。 可使用它向程序的日志消息添加前缀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetPrefix(<span class="string">&quot;main(): &quot;</span>)</span><br><span class="line">    log.Print(<span class="string">&quot;Hey, I&#x27;m a log!&quot;</span>)</span><br><span class="line">    log.Fatal(<span class="string">&quot;Hey, I&#x27;m an error log!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main(): <span class="number">2023</span>/<span class="number">04</span>/<span class="number">07</span> <span class="number">13</span>:<span class="number">44</span>:<span class="number">42</span> Hey, I<span class="string">&#x27;m a log!</span></span><br><span class="line"><span class="string">main(): 2023/04/07 13:44:42 Hey, I&#x27;</span>m an <span class="type">error</span> log!</span><br><span class="line">exit status <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>只需设置一次前缀，日志就会包含日志源自的函数的名称等信息。<br>可以<a target="_blank" rel="noopener" href="https://golang.org/pkg/log/">https://golang.org/pkg/log/</a></p>
<h3 id="记录到文件"><a href="#记录到文件" class="headerlink" title="记录到文件"></a>记录到文件</h3><p>在文件中添加日志后，可以将所有日志集中在一个位置，并将它们与其他事件关联。 此模式为典型模式：具有可能是临时的分布式应用程序，例如容器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;info.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    log.SetOutput(file)</span><br><span class="line">    log.Print(<span class="string">&quot;Hey, I&#x27;m a log!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行前面的代码时，在控制台中看不到任何内容。 在目录中，你应看到一个名为 <code>info.log</code> 的新文件，其中包含使用 <code>log.Print()</code> 函数发送的日志。 请注意，需要首先创建或打开文件，然后将 <code>log</code> 包配置为将所有输出发送到文件。 然后，可以像通常做法那样继续使用 <code>log.Print()</code> 函数。</p>
<h3 id="记录框架"><a href="#记录框架" class="headerlink" title="记录框架"></a>记录框架</h3><p>可能有 log 包中的函数不足以处理问题的情况。 你可能会发现，使用记录框架而不编写自己的库很有用。 Go 的几个记录框架有 <a target="_blank" rel="noopener" href="https://github.com/sirupsen/logrus">Logrus</a>、<a target="_blank" rel="noopener" href="https://github.com/rs/zerolog">zerolog</a>、<a target="_blank" rel="noopener" href="https://github.com/uber-go/zap">zap</a> 和 <a target="_blank" rel="noopener" href="https://github.com/apex/log">Apex</a>。<br>让我们来了解一下可以用 zerolog 做什么。<br>首先，你需要安装包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/rs/zerolog/log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我在安装的时候有报错<br>于是使用了：<code>go install github.com/rs/zerolog/log@latest</code></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/rs/zerolog&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/rs/zerolog/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line">    log.Print(<span class="string">&quot;Hey! I&#x27;m a log message!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;level&quot;</span>:<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;time&quot;</span>:<span class="number">1609855453</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Hey! I&#x27;m a log message!&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，你只需包含正确的导入名称，然后便可以像通常做法那样继续使用 <code>log.Print()</code> 函数。 另请注意输出更改为 JSON 格式。 在集中位置运行搜索时，JSON 是一种有用的日志格式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/rs/zerolog&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/rs/zerolog/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix</span><br><span class="line"></span><br><span class="line">    log.Debug().</span><br><span class="line">        Int(<span class="string">&quot;EmployeeID&quot;</span>, <span class="number">1001</span>).</span><br><span class="line">        Msg(<span class="string">&quot;Getting employee information&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log.Debug().</span><br><span class="line">        Str(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;John&quot;</span>).</span><br><span class="line">        Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;level&quot;</span>:<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;EmployeeID&quot;</span>:<span class="number">1001</span>,<span class="string">&quot;time&quot;</span>:<span class="number">1609855731</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Getting employee information&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;level&quot;</span>:<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>,<span class="string">&quot;time&quot;</span>:<span class="number">1609855731</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意是如何将员工 ID 添加为上下文。 它作为另一属性成为 <code>logline</code> 的一部分。 另外，务必要强调的是，你包含的字段是强类型的。<br>你可以使用 <code>zerolog</code> 实现其他功能，例如使用分级的日志记录、使用格式化的堆栈跟踪，以及使用多个记录器实例来管理不同输出。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://github.com/rs/zerolog">GitHub 站点</a>。</p>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><p>如你所见，Go 中的错误处理和日志记录与其他编程语言中的这些过程不同。 首先，Go 的错误处理方法非常简单。 使用 if 条件，调用的函数应返回多个值。 按照惯例，最后一个返回值为错误。 如果错误变量返回 nil，则不存在错误。 如果值不为 nil，则存在失败。 只需再次返回错误即可将错误传播到堆栈，并且可以根据需要添加更多上下文。<br>可以创建可重用为程序中常见错误消息的返回值的错误变量。<br>你还需要了解何时使用 panic。 我们已介绍 <code>panic</code> 和 <code>recover</code> 的工作原理。 仅当明确需要停止程序时，才应使用这些函数。 有时，即使你正确处理了错误，程序也可能会停止响应。 但这应该是异常，而不是规则。<br>最后，我们探讨了 Go 中日志记录的工作原理，你了解了如何使用标准库。 除了将日志打印到控制台之外，你还可以将日志发送到文件供稍后处理，然后将它们发送到一个集中位置。 当代码库扩大时，你可能需要执行其他操作，例如设置日志级别或配置不同输出。 标准库中不支持这些任务。 你将需要使用记录框架，例如 zerolog。</p>
<h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 中的方法是一种特殊类型的函数，但存在一个简单的区别：你必须在函数名称之前加入一个额外的参数。 此额外参数称为“接收方”。<br>如你希望分组函数并将其绑定到自定义类型，则方法非常有用。 <strong>Go 中的这一方法类似于在其他编程语言中创建类</strong>，因为它允许你实现面向对象编程 (OOP) 模型中的某些功能，例如嵌入、重载和封装。</p>
<h3 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h3><p>到目前为止，你仅将结构用作可在 Go 中创建的另一种自定义类型。 在此模块中你将了解到，通过添加方法你可以将行为添加到你所创建的结构中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable <span class="keyword">type</span>)</span></span> MethodName(parameters ...) &#123;</span><br><span class="line">    <span class="comment">// method functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，<strong>在声明方法之前，必须先创建结构</strong>。 假设你想要创建一个几何包，并决定创建一个名为 <code>triangle</code> 的三角形结构作为此程序包的一个组成部分。 然后，你需要使用一种方法来计算此三角形的周长。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t triangle)</span></span> perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.size * <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构看起来像普通结构，但 <code>perimeter()</code> 函数在函数名称之前有一个类型 <code>triangle</code> 的额外参数。 此接收方意味着，在使用结构时，你可以按如下方式调用函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := triangle&#123;<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter:&quot;</span>, t.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果尝试按平常的方式调用 <code>perimeter()</code> 函数，则此函数将无法正常工作，因为此函数的签名表明它需要接收方。 调用此方法的唯一方式是先声明一个结构，获取此方法的访问权限。 只要此方法属于不同的结构，你甚至可以为其指定相同的名称。 例如，你可以使用 <code>perimeter()</code> 函数声明一个 <code>square</code> 结构，具体如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> square <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t triangle)</span></span> perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.size * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s square)</span></span> perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.size * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := triangle&#123;<span class="number">3</span>&#125;</span><br><span class="line">    s := square&#123;<span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter (triangle):&quot;</span>, t.perimeter())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter (square):&quot;</span>, s.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Perimeter (triangle): <span class="number">9</span></span><br><span class="line">Perimeter (square): <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>通过对 <code>perimeter()</code> 函数的两次调用，编译器将根据接收方类型来确定要调用的函数。 此行为有助于在各程序包之间保持函数的一致性和名称的简短，并避免将包名称作为前缀。 在下一个单元讲解接口时，我们将介绍此行为的重要性。</p>
<h3 id="方法中的指针"><a href="#方法中的指针" class="headerlink" title="方法中的指针"></a>方法中的指针</h3><p>有时，方法需要更新变量。 或者，如果方法的参数太大，你可能希望避免复制它。 在遇到此类情况时，你需要使用指针传递变量的地址。 在之前的模块中，当我们在讨论指针时提到，每次在 Go 中调用函数时，Go 都会复制每个参数值以便使用。<br>如果你需要更新方法中的接收方变量，也会执行相同的行为。 例如，假设你要创建一个新方法以使三角形的大小增加一倍。 你需要在接收方变量中使用指针.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *triangle)</span></span> doubleSize() &#123;</span><br><span class="line">    t.size *= <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := triangle&#123;<span class="number">3</span>&#125;</span><br><span class="line">    t.doubleSize()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Size:&quot;</span>, t.size)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter:&quot;</span>, t.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size: <span class="number">6</span></span><br><span class="line">Perimeter: <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>如果方法仅可访问接收方的信息，则不需要在接收方变量中使用指针。 但是，依据 Go 的约定，如果结构的任何方法具有指针接收方，则此结构的所有方法都必须具有指针接收方。 即使此结构的某个方法不需要它也是如此。</p>
<h3 id="声明其他类型的方法"><a href="#声明其他类型的方法" class="headerlink" title="声明其他类型的方法"></a>声明其他类型的方法</h3><p>方法的一个关键方面在于，需要为任何类型定义方法，而不只是针对自定义类型（如结构）进行定义。 但是，你不能通过属于其他包的类型来定义结构。 因此，不能在基本类型（如 <code>string</code>）上创建方法。<br>尽管如此，你仍然可以利用一点技巧，基于基本类型创建自定义类型，然后将其用作基本类型。 例如，假设你要创建一个方法，以将字符串从小写字母转换为大写字母。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> upperstring <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s upperstring)</span></span> Upper() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.ToUpper(<span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := upperstring(<span class="string">&quot;Learning Go!&quot;</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    fmt.Println(s.Upper())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Learning Go!</span><br><span class="line">LEARNING GO!</span><br></pre></td></tr></table></figure>

<p>请注意，你在使用新对象 <code>s</code> 时，可以在首次打印其值时将其作为字符串。 然后，你在调用 <code>Upper</code> 方法时，<code>s</code> 会打印出类型字符串的所有大写字母。</p>
<h3 id="嵌入方法"><a href="#嵌入方法" class="headerlink" title="嵌入方法"></a>嵌入方法</h3><p>在之前的模块中，您已了解到可以在一个结构中使用属性，并将同一属性嵌入另一个结构中。 也就是说，可以重用来自一个结构的属性，以避免出现重复并保持代码库的一致性。 类似的观点也适用于方法。 即使接收方不同，也可以调用已嵌入结构的方法。<br>例如，假设你想要创建一个带有逻辑的新三角形结构，以加入颜色。 此外，你还希望继续使用之前声明的三角形结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coloredTriangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    triangle</span><br><span class="line">    color <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，你可以初始化 <code>coloredTriangle </code>结构，并从 <code>triangle</code> 结构调用 <code>perimeter()</code> 方法（甚至访问其字段）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := coloredTriangle&#123;triangle&#123;<span class="number">3</span>&#125;, <span class="string">&quot;blue&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Size:&quot;</span>, t.size)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter&quot;</span>, t.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size: <span class="number">3</span></span><br><span class="line">Perimeter <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>如果你熟悉 Java 或 C++ 等 OOP 语言，则可能会认为 <code>triangle</code> 结构看起来像基类，而 <code>coloredTriangle</code> 是一个子类（如继承），但事实并不是如此。 实际上，Go 编译器会通过创建如下的包装器方法来推广 <code>perimeter()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t coloredTriangle)</span></span> perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.triangle.perimeter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，接收方是 <code>coloredTriangle</code>，它从三角形字段调用 <code>perimeter()</code> 方法。 好的一点在于，你不必再创建之前的方法。 你可以选择创建，但 Go 已在内部为你完成了此工作。</p>
<h3 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h3><p>让我们回到之前讨论过的 <code>triangle</code> 示例。 如果要在 <code>coloredTriangle</code> 结构中更改 <code>perimeter()</code> 方法的实现，会发生什么情况？ 不能存在两个同名的函数。 但是，因为方法需要额外参数（接收方），所以，你可以使用一个同名的方法，只要此方法专门用于要使用的接收方即可。 利用这种区别就是重载方法的方式。<br>:::info<br>简而言之，接收方不一样，函数名可以一样，这就是重载。<br>:::<br>换而言之，如你想要更改其行为，可以编写我们讨论过的包装器方法。 如果彩色三角形的周长是普通三角形的两倍，则代码将如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t coloredTriangle)</span></span> perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.size * <span class="number">3</span> * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，无需更改之前编写的 <code>main()</code> 方法中的任何其他内容，具体将如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := coloredTriangle&#123;triangle&#123;<span class="number">3</span>&#125;, <span class="string">&quot;blue&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Size:&quot;</span>, t.size)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter&quot;</span>, t.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Size: <span class="number">3</span></span><br><span class="line">Perimeter <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>但是，如果你仍需要从 <code>triangle</code> 结构调用 <code>perimeter()</code> 方法，则可通过对其进行显示访问来执行此操作，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := coloredTriangle&#123;triangle&#123;<span class="number">3</span>&#125;, <span class="string">&quot;blue&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Size:&quot;</span>, t.size)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter (colored)&quot;</span>, t.perimeter())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter (normal)&quot;</span>, t.triangle.perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Size: <span class="number">3</span></span><br><span class="line">Perimeter (colored) <span class="number">18</span></span><br><span class="line">Perimeter (normal) <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可能已经注意到，在 Go 中，你可以替代方法，并在需要时仍访问原始方法。</p>
<h3 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h3><p>“封装”表示对象的发送方（客户端）无法访问某个方法。 通常，在其他编程语言中，你会将 <code>private</code> 或 <code>public</code> 关键字放在方法名称之前。 在 Go 中，只需使用大写标识符，即可公开方法，使用非大写的标识符将方法设为私有方法。<br>Go 中的封装仅在<strong>包</strong>之间有效。 换句话说，你只能隐藏来自其他程序包的实现详细信息，而不能隐藏程序包本身。<br>如要进行尝试，请创建新包 <code>geometry</code> 并按如下方式将三角形结构移入其中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> doubleSize() &#123;</span><br><span class="line">    t.size *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> SetSize(size <span class="type">int</span>) &#123;</span><br><span class="line">    t.size = size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> Perimeter() <span class="type">int</span> &#123;</span><br><span class="line">    t.doubleSize()</span><br><span class="line">    <span class="keyword">return</span> t.size * <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := geometry.Triangle&#123;&#125;</span><br><span class="line">    t.SetSize(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter&quot;</span>, t.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若访问 <code>doubleSize()</code> 方法，则程序会死机。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">23</span>: t.size undefined (cannot refer to unexported field or method size)</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>在该函数定义时调用，只需在大括号结束后，使用小括号将要传入的参数值包裹起来即可，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(text <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Prinln(text);</span><br><span class="line">    &#125;(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种调用匿名函数的方法是将匿名函数赋值给某个变量，然后通过变量调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    happy := <span class="function"><span class="keyword">func</span><span class="params">(text <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">        ftm.Println(text);</span><br><span class="line">    &#125;</span><br><span class="line">    happy(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go 中的接口是一种用于表示其他类型的行为的数据类型。 接口类似于对象应满足的蓝图或协定。 在你使用接口时，你的基本代码将变得更加灵活、适应性更强，因为你编写的代码未绑定到特定的实现。 因此，你可以快速扩展程序的功能。<br>与其他编程语言中的接口不同，Go 中的接口是满足隐式实现的。 Go 不提供用于实现接口的关键字。 因此，如果你之前使用的是其他编程语言中的接口，但不熟悉 Go，那么此概念可能会造成混淆。</p>
<h3 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h3><p>Go 中的接口类似于蓝图。 一种抽象类型，只包括具体类型必须拥有或实现的方法。<br>假设你希望在几何包中创建一个接口来指示形状必须实现的方法。 你可以按如下所示定义接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">    Perimeter() <span class="type">float64</span></span><br><span class="line">    Area() <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Shape</code> 接口表示你想要考虑 <code>Shape</code> 的任何类型都需要同时具有 <code>Perimeter()</code> 和 <code>Area()</code> 方法。 例如，在创建 <code>Square</code> 结构时，它必须实现两种方法，而不是仅实现一种。 另外，请注意接口不包含这些方法的实现细节（例如，用于计算某个形状的周长和面积）。 接口仅表示一种协定。 三角形、圆圈和正方形等形状有不同的计算面积和周长方式。</p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>正如上文所讨论的内容，你没有用于实现接口的关键字。 当 Go 中的接口具有接口所需的所有方法时，则满足按类型的隐式实现。<br>让我们创建一个 <code>Square</code> 结构，此结构具有 <code>Shape</code> 接口中的两个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Square)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.size * s.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Square)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.size * <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现字符串接口"><a href="#实现字符串接口" class="headerlink" title="实现字符串接口"></a>实现字符串接口</h3><p>扩展现有功能的一个简单示例是使用 Stringer，它是具有 String() 方法的接口，具体如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fmt.Printf</code> 函数使用此接口来输出值，这意味着你可以编写自定义 <code>String()</code> 方法来打印自定义字符串，具体如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name, Country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v is from %v&quot;</span>, p.Name, p.Country) <span class="comment">// 不用 Printf 因为返回值不同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rs := Person&#123;<span class="string">&quot;John Doe&quot;</span>, <span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line">    ab := Person&#123;<span class="string">&quot;Mark Collins&quot;</span>, <span class="string">&quot;United Kingdom&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n%s\n&quot;</span>, rs, ab)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">John Doe is from USA</span><br><span class="line">Mark Collins is from United Kingdom</span><br></pre></td></tr></table></figure>

<p>如你所见，你已使用自定义类型（结构）来写入 String() 方法的自定义版本。 此方法是在 Go 中实现接口的一种常用方法。</p>
<h3 id="扩展所有实现"><a href="#扩展所有实现" class="headerlink" title="扩展所有实现"></a>扩展所有实现</h3><p>假设你具有以下代码，并且希望通过编写负责处理某些数据的 <code>Writer</code> 方法的自定义实现来扩展其功能。<br>通过使用以下代码，你可以创建一个程序，此程序使用 GitHub API 从 Microsoft 获取三个存储库：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.github.com/users/microsoft/repos?page=15&amp;per_page=5&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.Copy(os.Stdout, resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:<span class="number">276496384</span>,<span class="string">&quot;node_id&quot;</span>:<span class="string">&quot;MDEwOlJlcG9zaXRvcnkyNzY0OTYzODQ=&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;-Users-deepakdahiya-Desktop-juhibubash-test21zzzzzzzzzzz&quot;</span>,<span class="string">&quot;full_name&quot;</span>:<span class="string">&quot;microsoft/-Users-deepakdahiya-Desktop-juhibubash-test21zzzzzzzzzzz&quot;</span>,<span class="string">&quot;private&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;owner&quot;</span>:&#123;<span class="string">&quot;login&quot;</span>:<span class="string">&quot;microsoft&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="number">6154722</span>,<span class="string">&quot;node_id&quot;</span>:<span class="string">&quot;MDEyOk9yZ2FuaXphdGlvbjYxNTQ3MjI=&quot;</span>,<span class="string">&quot;avatar_url&quot;</span>:<span class="string">&quot;https://avatars2.githubusercontent.com/u/6154722?v=4&quot;</span>,<span class="string">&quot;gravatar_id&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;url&quot;</span>:<span class="string">&quot;https://api.github.com/users/microsoft&quot;</span>,<span class="string">&quot;html_url&quot;</span>:<span class="string">&quot;https://github.com/micro</span></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>io.Copy(os.Stdout, resp.Body)</code> 调用是指将通过对 GitHub API 的调用获取的内容打印到终端。 假设你想要写入自己的实现以缩短你在终端中看到的内容。<br>在查看 <a target="_blank" rel="noopener" href="https://golang.org/pkg/io/#Copy">io.Copy 函数的源</a> 时，你将看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>如果你深入查看第一个参数 <code>dst Writer</code> 的详细信息，你会注意到 <code>Writer</code> 是 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Writer</code> 是接口，并且是 <code>Copy</code> 函数需要的对象，你可以编写 <code>Write</code> 方法的自定义实现。 因此，你可以自定义打印到终端的内容。<br>实现接口所需的第一项操作是创建自定义类型。 在这种情况下，你可以创建一个空结构，因为你只需按如下所示编写自定义 <code>Write</code> 方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customWriter <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你已准备就绪，可开始编写自定义 <code>Write</code> 函数。 此时，你还需要编写一个结构，以便将 JSON 格式的 API 响应解析为 Golang 对象。 你可以使用“JSON 转 Go”站点从 JSON 有效负载创建结构。 因此，Write 方法可能如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GitHubResponse []<span class="keyword">struct</span> &#123;</span><br><span class="line">    FullName <span class="type">string</span> <span class="string">`json:&quot;full_name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w customWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> resp GitHubResponse</span><br><span class="line">    json.Unmarshal(p, &amp;resp)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> resp &#123;</span><br><span class="line">        fmt.Println(r.FullName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你必须修改 <code>main()</code> 函数以使用你的自定义对象，具体如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.github.com/users/microsoft/repos?page=15&amp;per_page=5&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer := customWriter&#123;&#125;</span><br><span class="line">    io.Copy(writer, resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">microsoft/aed-blockchain-learn-content</span><br><span class="line">microsoft/aed-content-nasa-su20</span><br><span class="line">microsoft/aed-external-learn-template</span><br><span class="line">microsoft/aed-<span class="keyword">go</span>-learn-content</span><br><span class="line">microsoft/aed-learn-template</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GitHubResponse []<span class="keyword">struct</span> &#123;</span><br><span class="line">    FullName <span class="type">string</span> <span class="string">`json:&quot;full_name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> customWriter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w customWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> resp GitHubResponse</span><br><span class="line">    json.Unmarshal(p, &amp;resp)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> resp &#123;</span><br><span class="line">        fmt.Println(r.FullName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.github.com/users/microsoft/repos?page=15&amp;per_page=5&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writer := customWriter&#123;&#125;</span><br><span class="line">    io.Copy(writer, resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写自定义服务器API"><a href="#编写自定义服务器API" class="headerlink" title="编写自定义服务器API"></a>编写自定义服务器API</h3><p>如果你要创建服务器 API，你可能会发现此用例非常实用。 编写 Web 服务器的常用方式是使用 <code>net/http</code> 程序包中的 <code>http.Handler</code> 接口，具体如下所示（无需写入此代码）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="type">string</span>, h Handler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>请注意 <code>ListenAndServe</code> 函数需要服务器地址（如 <a target="_blank" rel="noopener" href="http://localhost:8000/">http://localhost:8000</a>）以及将响应从调用调度至服务器地址的 <code>Handler</code> 的实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;$%.2f&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;Go T-Shirt&quot;</span>: <span class="number">25</span>, <span class="string">&quot;Go Jacket&quot;</span>: <span class="number">55</span>&#125;</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, db))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>如果没有得到任何输出，说明情况不错。 此时，在新浏览器窗口中打开 <a target="_blank" rel="noopener" href="http://localhost:8000/">http://localhost:8000</a>，或在终端中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8000</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Go T-Shirt: <span class="variable">$25</span>.00</span><br><span class="line">Go Jacket: <span class="variable">$55</span>.00</span><br></pre></td></tr></table></figure>

<p>让我们一起慢慢回顾之前的代码，了解其用途并观察 Go 接口的功能。 首先，创建 <code>float32</code> 类型的自定义类型，然后编写 <code>String()</code> 方法的自定义实现，以便稍后使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dollars <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;$%.2f&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，写入 <code>http.Handler</code> 可使用的 <code>ServeHTTP</code> 方法的实现。 请注意，我们重新创建了自定义类型，但这次它是映射，而不是结构。 接下来，我们通过使用 <code>database</code> 类型作为接收方来写入 <code>ServeHTTP</code> 方法。 此方法的实现使用来自接收方的数据，然后对其进行循环访问，再输出每一项。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="type">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在 <code>main()</code> 函数中，我们将 <code>database</code> 类型实例化，并使用一些值对其进行初始化。 我们使用 http.<code>ListenAndServe</code> 函数启动了 HTTP 服务器，在其中定义了服务器地址，包括要使用的端口和实现 <code>ServeHTTP</code> 方法自定义版本的 <code>db</code> 对象。 在你运行程序时，Go 将使用此方法的实现，这也正是你在服务器 API 中使用和实现接口的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">&quot;Go T-Shirt&quot;</span>: <span class="number">25</span>, <span class="string">&quot;Go Jacket&quot;</span>: <span class="number">55</span>&#125;</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, db))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>http.Handle</code> 函数时，可以在服务器 API 中找到接口的其他用例。 有关详细信息，请参阅 Go 网站上<a target="_blank" rel="noopener" href="https://golang.org/doc/articles/wiki">编写 Web 应用程序</a>帖子。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发 *"></a>并发 *</h1><p>在开始了解 Go 中并发的工作原理之前，你可能需要忘记从其他编程语言中已经了解的知识。 Go 使用的方法不同。</p>
<ul>
<li><code>并发</code> 是指在同一个时间点上只能执行同一个任务，但是因为速度非常快，所以就像同时进行一样。</li>
<li><code>并行</code> 是指在一个时间点上同时处理多个任务。真正的并行，是需要电脑硬件的支持，单核的CPU是无法达到并行的。并行，他不一定快因为并行运行时是需要通信的，这种通信的成本还是很高的，而并发的程序成本很低。</li>
<li><code>进程</code> 就是一个独立功能的程序，在一个数据集中的一次动态执行过程，可以认为他是一个正在执行的程序，比如打开一个QQ就是在运行一个进程。</li>
<li><code>线程</code> 线程是被包含在进程之中的，它是比进程更小的能独立运行的基本单位 一个进程可以包含多个线程。例如、打开文档在你输入文字的时候他还在后台检测你输入的文字的大小写，还有拼写是否正确 ，这就是一个线程来检测的。</li>
<li><code>协程</code> 协程属于一种轻量级的线程，英文名 Goroutine 协程之间的调度由 Go运行时（runtime）管理。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/755493/1682301503495-39d793fb-3e17-44ff-a300-98915749a0ac.webp#averageHue=%23fdfbf7&clientId=ua705f9fa-dc00-4&from=paste&id=u28948486&originHeight=854&originWidth=1818&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u33793d15-10e6-4672-8c5a-26aaa472707&title="></p>
<h2 id="了解-goruntine（轻量线程）"><a href="#了解-goruntine（轻量线程）" class="headerlink" title="了解 goruntine（轻量线程） *"></a>了解 goruntine（轻量线程） *</h2><p>并发是独立活动的组合，就像 Web 服务器虽然同时处理多个用户请求，但它是自主运行的。<br>Go 有两种编写并发程序的样式。 一种是在其他语言中通过线程实现的传统样式。一种是—</p>
<blockquote>
<p> 在本模块中，你将了解 Go 的样式，其中值是在称为 goroutine 的独立活动之间传递的，以与进程进行通信。</p>
</blockquote>
<h3 id="Go-实现并发的方法"><a href="#Go-实现并发的方法" class="headerlink" title="Go 实现并发的方法"></a>Go 实现并发的方法</h3><p>通常，编写并发程序时最大的问题是在进程之间共享数据。但 Go 是通过 channel 来回传递数据的。 此方法意味着只有一个活动 (goroutine) 有权访问数据，设计上不存在争用条件。</p>
<h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>goroutine 是轻量线程中的并发活动，而不是在操作系统中进行的传统活动。<br>使用 go 关键字调用这个函数开启一个 goroutine 时候，即使这个函数有返回值也会忽略。goroutine 调用之后会立即返回，不会等待 goroutine 的执行结果，所以 goroutine 不会接收返回值。 把封装main函数的goroutine叫做主 goroutine，main 函数作为主 goroutine 执行，如果 main 函数中 goroutine 终止了，程序也将终止，其他的 goroutine 都不会再执行。<br>假设你有一个写入输出的程序和另一个计算两个数字相加的函数。 一个并发程序可以有数个 goroutine 同时调用这两个函数。<br>我们可以说，程序执行的第一个 goroutine 是 <code>main()</code> 函数。 如果要创建其他 goroutine，则必须在调用该函数之前使用 <code>go</code> 关键字，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    login()</span><br><span class="line">    <span class="keyword">go</span> launch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还会发现，许多程序喜欢使用匿名函数来创建 goroutine，在函数最后加上 <code>()</code> 后会直接执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    login()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        launch()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了查看运行中的 goroutine，让我们编写一个并发程序。</p>
<h3 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h3><p>其实go是运行在runtime调度器上的，它主要负责内存管理、垃圾回收、栈处理等等。也包含了Go运行时系统交互的操作，控制goroutine的操作，Go程序的调度器可以很合理的分配CPU资源给每一个任务。<br>Go1.5版本之前默认是单核执行的。从1.5之后使用可以通过<code>runtime.GOMAXPROCS()</code>来设置让程序并发执行，提高CPU的利用率。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//获取当前GOROOT目录</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;GOROOT:&quot;</span>, runtime.GOROOT())</span><br><span class="line">    <span class="comment">//获取当前操作系统</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;操作系统:&quot;</span>, runtime.GOOS)</span><br><span class="line">    <span class="comment">//获取当前逻辑CPU数量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;逻辑CPU数量：&quot;</span>, runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置最大的可同时使用的CPU核数  取逻辑cpu数量</span></span><br><span class="line">    n := runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">    fmt.Println(n) <span class="comment">//一般在使用之前就将cpu数量设置好 所以最好放在init函数内执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//goexit 终止当前goroutine</span></span><br><span class="line">    <span class="comment">//创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;start...&quot;</span>)</span><br><span class="line">        runtime.Goexit() <span class="comment">//终止当前goroutine</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">//主goroutine 休眠3秒 让子goroutine执行完</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main_end...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>runtime.Goexit()</code>函数之后，会立即停止当前 goroutine，其他的 goroutine 不会受影响。并且当前 goroutine 如果有未执行的 <code>defer</code> 还是会执行完 <code>defer</code> 操作。需要注意的是 <strong>不能</strong> 将<code>runtime.goexit()</code> 放在主 goroutine （main函数）中执行，否则会发生运行时恐慌。</p>
<h3 id="编写并发程序"><a href="#编写并发程序" class="headerlink" title="编写并发程序"></a>编写并发程序</h3><p>由于我们只想将重点放在并发部分，因此使用现有程序来检查 API 终结点是否响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">    apis := []<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;https://management.azure.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dev.azure.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://api.github.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://outlook.office.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://api.somewhereintheinternet.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://graph.microsoft.com&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">        _, err := http.Get(api)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;ERROR: %s is down!\n&quot;</span>, api)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed := time.Since(start)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUCCESS: https:<span class="comment">//management.azure.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//dev.azure.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//api.github.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//outlook.office.com/ is up and running!</span></span><br><span class="line">ERROR: https:<span class="comment">//api.somewhereintheinternet.com/ is down!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//graph.microsoft.com is up and running!</span></span><br><span class="line">Done! It took <span class="number">1.658436834</span> seconds!</span><br></pre></td></tr></table></figure>

<p>这里没有什么特别之处，但我们可以做得更好。 或许我们可以同时检查所有站点？ 此程序可以在 500 毫秒的时间内完成，不需要耗费将近两秒。<br>请注意，我们需要并发运行的代码部分是向站点进行 HTTP 调用的部分。 换句话说，我们需要为程序要检查的每个 API 创建一个 goroutine。<br>为了创建 goroutine，我们需要在调用函数前使用 <code>go</code> 关键字。 但我们在这里没有函数。 让我们重构该代码并创建一个新函数，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkAPI</span><span class="params">(api <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    _, err := http.Get(api)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;ERROR: %s is down!\n&quot;</span>, api)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们不再需要 <code>continue</code> 关键字，因为我们不在 <code>for</code> 循环中。 要停止函数的执行流，只需使用 <code>return</code> 关键字。 现在，我们需要修改 <code>main()</code> 函数中的代码，为每个 API 创建一个 goroutine，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">    <span class="keyword">go</span> checkAPI(api)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行程序，看看发生了什么。<br>看起来程序不再检查 API 了，对吗？ 显示的内容可能与以下输出类似：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Done! It took <span class="number">1.506e-05</span> seconds!</span><br></pre></td></tr></table></figure>

<p>速度可真快！ 发生了什么情况？ 你会看到最后一条消息，指出程序已完成，因为 Go 为循环中的每个站点创建了一个 goroutine，并且它立即转到下一行。<br>即使看起来 <code>checkAPI</code> 函数没有运行，它实际上是在运行。 它只是没有时间完成。 请注意，如果在循环之后添加一个睡眠计时器会发生什么，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">    <span class="keyword">go</span> checkAPI(api)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ERROR: https:<span class="comment">//api.somewhereintheinternet.com/ is down!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//api.github.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//management.azure.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//dev.azure.com is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//outlook.office.com/ is up and running!</span></span><br><span class="line">SUCCESS: https:<span class="comment">//graph.microsoft.com is up and running!</span></span><br><span class="line">Done! It took <span class="number">3.002114573</span> seconds!</span><br></pre></td></tr></table></figure>

<p>看起来似乎起作用了，对吧？ 不完全如此。 如果你想在列表中添加一个新站点呢？ 也许三秒钟是不够的。 你怎么知道？ 你无法管理。 必须有更好的方法，这就是我们在下一节讨论 channel 时要涉及的内容。</p>
<h2 id="将-channel-用作通信机制"><a href="#将-channel-用作通信机制" class="headerlink" title="将 channel 用作通信机制"></a>将 channel 用作通信机制</h2><p>Go 中的 channel 是 goroutine 之间的通信机制。 请记住 Go 的并发方法是：“不是通过共享内存通信；而是通过通信共享内存。”当你需要将值从一个 goroutine 发送到另一个时，可以使用通道。</p>
<h3 id="Channel-语法"><a href="#Channel-语法" class="headerlink" title="Channel 语法"></a>Channel 语法</h3><p>由于 channel 是发送和接收数据的通信机制，因此它也有类型之分。 这意味着你只能发送 channel 支持的数据类型。 除使用关键字 <code>chan</code> 作为 channel 的数据类型外，还需指定将通过 channel 传递的数据类型，如 <code>int</code> 类型。<br>每次声明一个 channel 或希望在函数中指定一个 channel 作为参数时，都需要使用 <code>chan &lt;type&gt;</code>，如 <code>chan int</code>。 若要创建通道，需使用内置的 <code>make()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>一个 channel 可以执行两项操作：发送数据和接收数据。 若要指定 channel 具有的操作类型，需要使用 channel 运算符 <code>&lt;-</code>。 此外，在 channel 中发送数据和接收数据属于阻止操作。 你一会儿就会明白为何如此。<br>如果希望通道仅发送数据，请在通道之后使用 <code>&lt;-</code> 运算符。 如果希望通道接收数据，请在通道之前使用 <code>&lt;-</code> 运算符，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">// sends (or writes ) x through channel ch</span></span><br><span class="line">x = &lt;-ch <span class="comment">// x receives (or reads) data sent to the channel ch</span></span><br><span class="line">&lt;-ch <span class="comment">// receives data, but the result is discarded</span></span><br></pre></td></tr></table></figure>

<p>可在 channel 中执行的另一项操作是关闭 channel。 若要关闭通道，使用内置的 <code>close()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>当你关闭通道时，你希望数据将不再在该通道中发送。 如果试图将数据发送到已关闭的 channel，则程序将发生严重错误。 如果试图通过已关闭的 channel 接收数据，则可以读取发送的所有数据。 随后的每次“读取”都将返回一个零值。<br>让我们回到之前创建的程序，然后使用通道来删除睡眠功能。 首先，让我们在 <code>main</code> 函数中创建一个字符串 channel，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，删除睡眠行 <code>time.Sleep(3 * time.Second)</code>。<br>现在，我们可以使用 channel 在 goroutine 之间进行通信。 应重构代码并通过通道发送该消息，而不是在 <code>checkAPI</code> 函数中打印结果。 要使用该函数中的 channel，需要添加 channel 作为参数。 <code>checkAPI</code> 函数应如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkAPI</span><span class="params">(api <span class="type">string</span>, ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    _, err := http.Get(api)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ch &lt;- fmt.Sprintf(<span class="string">&quot;ERROR: %s is down!\n&quot;</span>, api)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch &lt;- fmt.Sprintf(<span class="string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们必须使用 <code>fmt.Sprintf</code> 函数，因为我们不想打印任何文本，只需利用通道发送格式化文本。 另请注意，我们在 channel 变量之后使用 <code>&lt;-</code> 运算符来发送数据。<br>现在，你需要更改 <code>main</code> 函数以发送 channel 变量并接收要打印的数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">    <span class="keyword">go</span> checkAPI(api, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(&lt;-ch)</span><br></pre></td></tr></table></figure>

<p>请注意，我们在 channel 之前使用 <code>&lt;-</code> 运算符来表明我们想要从 channel 读取数据。<br>重新运行程序时，会看到如下所示的输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: https:<span class="comment">//api.somewhereintheinternet.com/ is down!</span></span><br><span class="line"></span><br><span class="line">Done! It took <span class="number">0.007401217</span> seconds!</span><br></pre></td></tr></table></figure>

<p>至少它不用调用睡眠函数就可以工作，对吧？ 但它仍然没有达到我们的目的。 我们只看到其中一个 goroutine 的输出，而我们共创建了五个 goroutine。 在下一节中，我们来看看这个程序为什么是这样工作的。</p>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h3><h2 id="了解有缓冲-channel"><a href="#了解有缓冲-channel" class="headerlink" title="了解有缓冲 channel"></a>了解有缓冲 channel</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/myimages/WeChat.jpg" alt="Felix/蔡济阳 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/myimages/AliPay.jpg" alt="Felix/蔡济阳 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Felix/蔡济阳
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://caijiyang.gitee.io/2023/07/12/1%20%E5%90%8E%E7%AB%AF/1.4%20Go/Go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="Go 语言基础">http://caijiyang.gitee.io/2023/07/12/1 后端/1.4 Go/Go-语言基础/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN,en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/12/4%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/4.1%20Unity/4.1.1%202D/Unity2D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%AE%9E%E8%AE%B0/" rel="prev" title="Unity2D游戏开发流程实记（更新中）">
                  <i class="fa fa-chevron-left"></i> Unity2D游戏开发流程实记（更新中）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/12/7%20%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/" rel="next" title="Hexo 博客搭建流程">
                  Hexo 博客搭建流程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20018119号-1 </a>
      <img src="/myimages/beian.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41152302000155" rel="noopener" target="_blank">41152302000155 </a>
  </div>
  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Felix/蔡济阳</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Caijiyang" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
